{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/what_is_ajax.png","path":"images/what_is_ajax.png","modified":1,"renderable":0},{"_id":"themes/tkl/source/css/animate.css","path":"css/animate.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/animsition.min.css","path":"css/animsition.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/all.styl","path":"css/all.styl","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/flexslider.css","path":"css/flexslider.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/iconList.css","path":"css/iconList.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/ie8.css","path":"css/ie8.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/screen.css","path":"css/screen.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/slidebars.min.css","path":"css/slidebars.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.eot","path":"fonts/icons.eot","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.woff","path":"fonts/icons.woff","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/arta.css","path":"highlightjs/arta.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/ascetic.css","path":"highlightjs/ascetic.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/brown_paper.css","path":"highlightjs/brown_paper.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/brown_papersq.png","path":"highlightjs/brown_papersq.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/dark.css","path":"highlightjs/dark.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/default.css","path":"highlightjs/default.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/far.css","path":"highlightjs/far.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/docco.css","path":"highlightjs/docco.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/foundation.css","path":"highlightjs/foundation.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/github.css","path":"highlightjs/github.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/googlecode.css","path":"highlightjs/googlecode.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/idea.css","path":"highlightjs/idea.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/ir_black.css","path":"highlightjs/ir_black.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/mono-blue.css","path":"highlightjs/mono-blue.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/magula.css","path":"highlightjs/magula.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/monokai.css","path":"highlightjs/monokai.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/monokai_sublime.css","path":"highlightjs/monokai_sublime.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/obsidian.css","path":"highlightjs/obsidian.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/pojoaque.css","path":"highlightjs/pojoaque.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/pojoaque.jpg","path":"highlightjs/pojoaque.jpg","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/railscasts.css","path":"highlightjs/railscasts.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/rainbow.css","path":"highlightjs/rainbow.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/school_book.css","path":"highlightjs/school_book.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/school_book.png","path":"highlightjs/school_book.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/solarized_dark.css","path":"highlightjs/solarized_dark.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/solarized_light.css","path":"highlightjs/solarized_light.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/sunburst.css","path":"highlightjs/sunburst.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-blue.css","path":"highlightjs/tomorrow-night-blue.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-bright.css","path":"highlightjs/tomorrow-night-bright.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-eighties.css","path":"highlightjs/tomorrow-night-eighties.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night.css","path":"highlightjs/tomorrow-night.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow.css","path":"highlightjs/tomorrow.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/xcode.css","path":"highlightjs/xcode.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/vs.css","path":"highlightjs/vs.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/zenburn.css","path":"highlightjs/zenburn.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/close.png","path":"img/close.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/html5shiv.min.js","path":"js/html5shiv.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery.ajaxchimp.min.js","path":"js/jquery.ajaxchimp.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery.flexslider-min.js","path":"js/jquery.flexslider-min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/respond.min.js","path":"js/respond.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/scripts.js","path":"js/scripts.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.svg","path":"fonts/icons.svg","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery-1.11.1.min.js","path":"js/jquery-1.11.1.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/bg_img.jpg","path":"img/bg_img.jpg","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/plugins.min.js","path":"js/plugins.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/bg_img_bear.jpg","path":"img/bg_img_bear.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ea747fc3ba459a5b2769ef640998e9f642725ac9","modified":1488802798000},{"_id":"themes/tkl/.DS_Store","hash":"c0a21290008e5d4d6e22f4e72967bd5b8d79ca48","modified":1485240500000},{"_id":"themes/tkl/LICENSE","hash":"c700a8b9312d24bdc57570f7d6a131cf63d89016","modified":1485141475000},{"_id":"themes/tkl/.git","hash":"015b90824e4e713871fad3fef5f37f4198e555fa","modified":1485141475000},{"_id":"themes/tkl/README.md","hash":"f5e4750b3da64867597b466d861688a6dbcb3f02","modified":1485142319000},{"_id":"themes/tkl/_config.yml","hash":"bc1d6ddc095eb2c84b5c092cddcd3a9589e40d54","modified":1485229217000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1486269052000},{"_id":"source/_posts/Promise-JavaScript异步编程.md","hash":"9515aeedf82890cf74d02301d7d7dfc4f74edf24","modified":1488803004000},{"_id":"source/_posts/React组件单元测试.md","hash":"99baf496235c0a5a8fa6b430ef60d34a25daf0ce","modified":1485243669000},{"_id":"source/_posts/XMLHttpRequest.md","hash":"830d31270f16c7194c609f7565f760b63ce8ab64","modified":1485243680000},{"_id":"source/_posts/Yarn-模块管理工具.md","hash":"bd1445c0bcdbda26babfcced41b36b4604745cd5","modified":1485243719000},{"_id":"source/_posts/react-lifecycle.md","hash":"047e3c5d82469b7423e550ed7945aaa22e6f9b6b","modified":1485243697000},{"_id":"source/about/index.md","hash":"cdfe52b7b413cb75385b3440f23cfca0bcedb6fb","modified":1485227486000},{"_id":"source/images/what_is_ajax.png","hash":"5f0f3f2122152e38e08fa58d05e0a021be17e36b","modified":1485141447000},{"_id":"themes/tkl/layout/about.ejs","hash":"9a6da09178130877fa7c6852fe41c714b46b773c","modified":1485228316000},{"_id":"themes/tkl/layout/archive.ejs","hash":"43e2dd0a6f82acba7e8dae563ff358854e63338d","modified":1485141475000},{"_id":"themes/tkl/layout/category.ejs","hash":"7b863018dd9b05f8a1ebabf58e96add0049d7abe","modified":1485141475000},{"_id":"themes/tkl/layout/index.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1485141475000},{"_id":"themes/tkl/layout/layout.ejs","hash":"943af95c1710ceb334b2e57248e78bd93e3832b8","modified":1485245263000},{"_id":"themes/tkl/layout/page.ejs","hash":"f2c2725c591d5b24da9cf632fd6c3587867cc2c0","modified":1485141475000},{"_id":"themes/tkl/layout/post.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1485141475000},{"_id":"themes/tkl/layout/tag.ejs","hash":"3e22a8a5281d7648d90b604f95cbdd1790008a70","modified":1485141475000},{"_id":"themes/tkl/source/.DS_Store","hash":"8e2df1a9a9f49abd2ba6bcfd38f350355d184b4a","modified":1485162618000},{"_id":"themes/tkl/layout/_widget/archive.ejs","hash":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/category.ejs","hash":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/recent_posts.ejs","hash":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/tag.ejs","hash":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/tagcloud.ejs","hash":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1485141475000},{"_id":"themes/tkl/layout/casper/about.ejs","hash":"7108cb498135e862b5b30077a370a53b6571e00e","modified":1485331759000},{"_id":"themes/tkl/layout/casper/after_all.ejs","hash":"bf795bd5c6b645fcf14292d602dabd9e6d49cae3","modified":1485141475000},{"_id":"themes/tkl/layout/casper/archive.ejs","hash":"e89d44b7c0104b47d93418c27f4b2d8c0da2ba28","modified":1485331756000},{"_id":"themes/tkl/layout/casper/footer.ejs","hash":"1559fa25d44c661fbd50f8ba6c0b96c663988c7f","modified":1485160401000},{"_id":"themes/tkl/layout/casper/head.ejs","hash":"32596dce306a2e528b2681ddc1c15bb768b2cf44","modified":1485141475000},{"_id":"themes/tkl/layout/casper/header.ejs","hash":"89782c924beb7fa7ef32f85733832823c524a711","modified":1485244526000},{"_id":"themes/tkl/layout/casper/index.ejs","hash":"0dedd857571b1521197be334e5df712d4e08b10f","modified":1485332884000},{"_id":"themes/tkl/layout/casper/post.ejs","hash":"f0e9270e45bfc8cf8b533a71f09ce1cd2cd5c543","modified":1485141475000},{"_id":"themes/tkl/source/css/animate.css","hash":"fca75b84887199a0ed8e0f056ff30f5a1302f324","modified":1485141475000},{"_id":"themes/tkl/source/css/animsition.min.css","hash":"59033074f6594a0d87c759e2b8cf9baa3a62ed6a","modified":1485141475000},{"_id":"themes/tkl/source/css/all.styl","hash":"b281ab5f908e16005c9e4e57f51ac7da9c4aab29","modified":1485141475000},{"_id":"themes/tkl/source/css/custom.css","hash":"02e701a0dddde40f940df04f48aa3b0e27fd9f5b","modified":1485141475000},{"_id":"themes/tkl/source/css/flexslider.css","hash":"faebc8c54ca41e3c9936edaffbabbebd512c6d5a","modified":1485141475000},{"_id":"themes/tkl/source/css/iconList.css","hash":"f78ffffb4be40a6b0eb6ee109c958ccd062d1ae5","modified":1485141475000},{"_id":"themes/tkl/source/css/ie8.css","hash":"cfdfe07ecc9f3afa5bab47155b49f0924f62d2c2","modified":1485141475000},{"_id":"themes/tkl/source/css/screen.css","hash":"a13c2c6fe420f76083df2da6d7b2d765dd8b467e","modified":1485141475000},{"_id":"themes/tkl/source/css/slidebars.min.css","hash":"a802c15d9bf06005b463901be8325d8ce38b5b04","modified":1485141475000},{"_id":"themes/tkl/source/css/syntax.styl","hash":"f39ea1e483c9244f39003d3efd20deb535ecddc7","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/arta.css","hash":"08766ac9d70bde457fea9c553140029f57ace65a","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/ascetic.css","hash":"dd5e0c6c11bc199884cc5abf7310e79ce8018d0d","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/brown_paper.css","hash":"2a987d30dd142a5c316ace70e919e3312707ebbd","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/brown_papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/dark.css","hash":"38045930b1d862bb6e14960e94e63782145a598f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/default.css","hash":"108ad8410aa3004eafc452ae60771a2ae24d7988","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/far.css","hash":"8178ac70abe577ae8345f1f6291bf7d489ad384d","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/docco.css","hash":"70199b44d688d0a22851bd5481260f24160a38ee","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/foundation.css","hash":"308c2e0458fc117b323f7d9ce1644f7b4e52d99e","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/github.css","hash":"53f47e65e6e0e6068baf5c4b638b04d2f4e0b0bc","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/googlecode.css","hash":"731e74bcdfd1b68aae5b5805540f727c31309ba2","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/idea.css","hash":"fb77c293850c454c1f0c72628c0b301537765ad2","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/ir_black.css","hash":"2da52e8562b412039b5816e1a3a2f59e7dff0c27","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/mono-blue.css","hash":"c143e9d8c62dc71ca39bc0b6c127464ed2396e4f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/magula.css","hash":"5666f49986f05fb8956e0c3065a383b252779442","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/monokai.css","hash":"a0edb8327c191516a04d456db8aae9044055a5cf","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/monokai_sublime.css","hash":"6b4716416b1bba643d3a7926221ce6d83a139141","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/obsidian.css","hash":"d6c264e1973beb9f20001b9a4013e9983923b34e","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/pojoaque.css","hash":"c9b048dc71c5b45d5cb3daac8f332a7e5d13b20f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/railscasts.css","hash":"aeb6ecd79552b9611d447fe56de5266954ea055c","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/rainbow.css","hash":"b0e18f0f7fa08d5ad11956e2d9cc5e2ffdd514f3","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/school_book.css","hash":"f257d41cdca2609fa4c664df9cc14b48e2bcb09f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/school_book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/solarized_dark.css","hash":"007f9f1e7addf7e2040734cd1f733d041432c335","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/solarized_light.css","hash":"a85878fd70ecd03c71944df1acbbf320bac7979f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/sunburst.css","hash":"e72bc116795505c1fcae35bc69045043fc34a243","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-blue.css","hash":"e2bed22abcdf3f2b8ca3a1a73624751d3edc4e64","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-bright.css","hash":"afdb004743a8d2b52d38c7a1fce32d631a0f3ded","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-eighties.css","hash":"9603bc778de2dabd0ce1e7ee272a047338a8b99c","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night.css","hash":"48cd18ce93daa491d89eb63e5fe3ab640ff56d74","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow.css","hash":"a184e23b28b6a6401ecfc35e0a94de0bada589e4","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/xcode.css","hash":"78cb5758ce4085aa51edb6c5beb64d8f4511edd7","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/vs.css","hash":"13e2f7ec2e197d79f4fc36768ea4a0663d41e1c0","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/zenburn.css","hash":"73dafd21563f5fc3bb74856d4abf97c447a27772","modified":1485141475000},{"_id":"themes/tkl/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1485162603000},{"_id":"themes/tkl/source/img/close.png","hash":"e52e6a61877efd98ddad9ca31ece27e8ee977327","modified":1485141475000},{"_id":"themes/tkl/source/img/favicon.ico","hash":"5557409832d7bb97e0e236acb758aabdfa0065c9","modified":1485141475000},{"_id":"themes/tkl/source/img/logo.png","hash":"c25534b76207ae573fe0681a1d52392ff321f517","modified":1485141475000},{"_id":"themes/tkl/source/js/html5shiv.min.js","hash":"bb51a5f6c394989bb06e4171179354c6d05ec8f8","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery.ajaxchimp.min.js","hash":"9be17785b0d816e1cd6bc45908e1805e0522fe18","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery.flexslider-min.js","hash":"51b3a7d882f438d53dc69ca5289e92254160c09a","modified":1485141475000},{"_id":"themes/tkl/source/js/respond.min.js","hash":"b5aba40d65b0d6f85859db47f757ea971a0efd30","modified":1485141475000},{"_id":"themes/tkl/source/js/scripts.js","hash":"4e4ebd697d00d3d0fcea7cbf78f5a7312e2f22ed","modified":1485141475000},{"_id":"themes/tkl/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1485141475000},{"_id":"themes/tkl/source/css/style.css","hash":"3e26ab1f78440b22938b4d012b43b6d6859c35b3","modified":1485333131000},{"_id":"themes/tkl/source/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery-1.11.1.min.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/comments.ejs","hash":"8246718d5a5838d6093971d52b8b217da3f4ea8c","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/meta.ejs","hash":"c984cdc774bc884b33c8d87e3b59728cfdee773c","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/duoshuo.ejs","hash":"2e043e5950bafefc08616a31ce37762ccf838cfb","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/navigation.ejs","hash":"2cdf5a26df9e43d0df1a08aad1cb934e7aea3b4a","modified":1485141475000},{"_id":"themes/tkl/source/img/bg_img.jpg","hash":"36263c65562c7ff11bc2b973e235ebce57a7773c","modified":1485162027000},{"_id":"themes/tkl/source/js/plugins.min.js","hash":"5d2edd4ecc4b27af81a3255ca8a253d23fc518e1","modified":1485141475000},{"_id":"themes/tkl/source/img/bg_img_bear.jpg","hash":"3dd99bb3c09798ce11837521222944570756437c","modified":1485141475000},{"_id":"public/sitemap.xml","hash":"9b723c35d31978cfa54c96d0ef3964932aca5aae","modified":1488803012868},{"_id":"public/content.json","hash":"f16219970302c06e04f5b35cc0b1dfaa12a8c17e","modified":1488803012881},{"_id":"public/about/index.html","hash":"8298ec1c713594d7ca4902f75a3727daa0d9ecd3","modified":1488803013007},{"_id":"public/20161230/XMLHttpRequest/index.html","hash":"59fe0db4b67dd2df28efb22936cd10863ec36c84","modified":1488803013017},{"_id":"public/20161229/react-lifecycle/index.html","hash":"8254b1df41cdbc99615b483d3620cfe3d747818b","modified":1488803013017},{"_id":"public/categories/react/index.html","hash":"f1586ec998fc4b3a3b3402618e6685a8ef2e7f14","modified":1488803013017},{"_id":"public/categories/yarn/index.html","hash":"9d83317f9c2659c4a2f48f57299ba980428094f1","modified":1488803013018},{"_id":"public/categories/http/index.html","hash":"69be4232070a5212c7799ea4863e46cea40f1546","modified":1488803013018},{"_id":"public/categories/react/test/index.html","hash":"a371375ce55be0b501f6240b092d16e773296757","modified":1488803013018},{"_id":"public/categories/yarn/npm/index.html","hash":"d07e3048f96f21e8817c19946824cf983285ab04","modified":1488803013018},{"_id":"public/categories/yarn/npm/工具/index.html","hash":"267df42bb58438464000e2bcc6f6a87337a8ff54","modified":1488803013018},{"_id":"public/archives/index.html","hash":"1dac7cb3db295fd8c053aa07268fa0e531c5015e","modified":1488803013018},{"_id":"public/archives/2016/index.html","hash":"63af9d641e0a66550da7788b3c3431d2d16a53c5","modified":1488803013018},{"_id":"public/archives/2016/12/index.html","hash":"7abc713d8c5e833dc92a3be42425e8de18b3f51f","modified":1488803013018},{"_id":"public/archives/2017/index.html","hash":"1eb6d705c01e52e52f3550c65093937700bf1f5c","modified":1488803013018},{"_id":"public/archives/2017/01/index.html","hash":"0241f48e2490e1100a0563ab5aa7f0205122bb2f","modified":1488803013018},{"_id":"public/archives/2017/03/index.html","hash":"d9a540cf7c518a7cb076fc1baf01e165e8cfb89d","modified":1488803013018},{"_id":"public/tags/promise/index.html","hash":"b45f04d0ddbcfc4b5cb28f483932e5ef443d9249","modified":1488803013018},{"_id":"public/tags/异步编程/index.html","hash":"1330e6780f4c0dbef6e23f49b9324d74d7c449a1","modified":1488803013018},{"_id":"public/tags/陈小饼/index.html","hash":"696919a76559866c25581101c28ffb129ae9f4b5","modified":1488803013018},{"_id":"public/tags/react/index.html","hash":"862626b1e331b9b586f13d05cb262d9c951161a5","modified":1488803013018},{"_id":"public/tags/test/index.html","hash":"d93cb5dca57fe4f5fe702d04a5fbdc2373afe83b","modified":1488803013018},{"_id":"public/tags/Yarn/index.html","hash":"4947bc0e634c350abc5b0552d2a44b283b103a02","modified":1488803013018},{"_id":"public/tags/NPM/index.html","hash":"c1be8abd36eeeff6d74b4385abfbc25379708741","modified":1488803013018},{"_id":"public/tags/工具/index.html","hash":"8ac37dd7628bddfd1522b0c3aab9c7939b6cb978","modified":1488803013018},{"_id":"public/tags/http/index.html","hash":"5d3c71d28cd12825fc5eeb0c16a6d1088eac0531","modified":1488803013018},{"_id":"public/20170305/Promise-JavaScript异步编程/index.html","hash":"6cd498e5b0b565aa4bf0f49fd83ca48e94357569","modified":1488803013018},{"_id":"public/20170118/React组件单元测试/index.html","hash":"193deb18336c9d07bc70df3df74ada136f0c37b2","modified":1488803013019},{"_id":"public/20170111/Yarn-模块管理工具/index.html","hash":"d3248753fdfd21c8966f99d3fc34662ba70e4243","modified":1488803013019},{"_id":"public/index.html","hash":"e5b0d6a5f5f0cab070601d2e50333432a5fa1450","modified":1488803013019},{"_id":"public/categories/promise/index.html","hash":"442e6b4c63f496f0e86c74fe1faace3991f0852e","modified":1488803013025},{"_id":"public/categories/promise/异步编程/index.html","hash":"a710d9d28ade79827cee2823df4f991bcfbb46ab","modified":1488803013025},{"_id":"public/images/what_is_ajax.png","hash":"5f0f3f2122152e38e08fa58d05e0a021be17e36b","modified":1488803013030},{"_id":"public/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1488803013030},{"_id":"public/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1488803013031},{"_id":"public/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1488803013031},{"_id":"public/highlightjs/brown_papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1488803013031},{"_id":"public/highlightjs/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1488803013031},{"_id":"public/highlightjs/school_book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1488803013031},{"_id":"public/img/close.png","hash":"e52e6a61877efd98ddad9ca31ece27e8ee977327","modified":1488803013031},{"_id":"public/img/favicon.ico","hash":"5557409832d7bb97e0e236acb758aabdfa0065c9","modified":1488803013031},{"_id":"public/img/logo.png","hash":"c25534b76207ae573fe0681a1d52392ff321f517","modified":1488803013031},{"_id":"public/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1488803013157},{"_id":"public/css/custom.css","hash":"02e701a0dddde40f940df04f48aa3b0e27fd9f5b","modified":1488803013172},{"_id":"public/css/animate.css","hash":"fca75b84887199a0ed8e0f056ff30f5a1302f324","modified":1488803013172},{"_id":"public/css/flexslider.css","hash":"faebc8c54ca41e3c9936edaffbabbebd512c6d5a","modified":1488803013172},{"_id":"public/css/iconList.css","hash":"f78ffffb4be40a6b0eb6ee109c958ccd062d1ae5","modified":1488803013172},{"_id":"public/css/ie8.css","hash":"cfdfe07ecc9f3afa5bab47155b49f0924f62d2c2","modified":1488803013172},{"_id":"public/css/screen.css","hash":"a13c2c6fe420f76083df2da6d7b2d765dd8b467e","modified":1488803013172},{"_id":"public/css/slidebars.min.css","hash":"a802c15d9bf06005b463901be8325d8ce38b5b04","modified":1488803013172},{"_id":"public/css/syntax.css","hash":"d5923a6251a113ac02916bcd1119356bd780d7ef","modified":1488803013172},{"_id":"public/highlightjs/ascetic.css","hash":"ef259aecdc8f1367dcf890d6467369300c4c0d07","modified":1488803013173},{"_id":"public/highlightjs/arta.css","hash":"08766ac9d70bde457fea9c553140029f57ace65a","modified":1488803013173},{"_id":"public/highlightjs/brown_paper.css","hash":"2a987d30dd142a5c316ace70e919e3312707ebbd","modified":1488803013173},{"_id":"public/highlightjs/dark.css","hash":"2c2b4eb2562d812d95a26da0ffae51371b383713","modified":1488803013173},{"_id":"public/highlightjs/default.css","hash":"108ad8410aa3004eafc452ae60771a2ae24d7988","modified":1488803013173},{"_id":"public/highlightjs/far.css","hash":"8178ac70abe577ae8345f1f6291bf7d489ad384d","modified":1488803013173},{"_id":"public/highlightjs/docco.css","hash":"70199b44d688d0a22851bd5481260f24160a38ee","modified":1488803013173},{"_id":"public/highlightjs/foundation.css","hash":"308c2e0458fc117b323f7d9ce1644f7b4e52d99e","modified":1488803013173},{"_id":"public/highlightjs/github.css","hash":"53f47e65e6e0e6068baf5c4b638b04d2f4e0b0bc","modified":1488803013173},{"_id":"public/highlightjs/googlecode.css","hash":"731e74bcdfd1b68aae5b5805540f727c31309ba2","modified":1488803013173},{"_id":"public/highlightjs/idea.css","hash":"fb77c293850c454c1f0c72628c0b301537765ad2","modified":1488803013173},{"_id":"public/highlightjs/ir_black.css","hash":"2da52e8562b412039b5816e1a3a2f59e7dff0c27","modified":1488803013173},{"_id":"public/highlightjs/mono-blue.css","hash":"c143e9d8c62dc71ca39bc0b6c127464ed2396e4f","modified":1488803013173},{"_id":"public/highlightjs/magula.css","hash":"9c53982a77259331c1dc3b24ef744dd76b3fe643","modified":1488803013173},{"_id":"public/highlightjs/monokai.css","hash":"a0edb8327c191516a04d456db8aae9044055a5cf","modified":1488803013173},{"_id":"public/highlightjs/monokai_sublime.css","hash":"6b4716416b1bba643d3a7926221ce6d83a139141","modified":1488803013173},{"_id":"public/highlightjs/obsidian.css","hash":"d6c264e1973beb9f20001b9a4013e9983923b34e","modified":1488803013173},{"_id":"public/highlightjs/pojoaque.css","hash":"c9b048dc71c5b45d5cb3daac8f332a7e5d13b20f","modified":1488803013173},{"_id":"public/highlightjs/railscasts.css","hash":"aeb6ecd79552b9611d447fe56de5266954ea055c","modified":1488803013173},{"_id":"public/highlightjs/rainbow.css","hash":"b0e18f0f7fa08d5ad11956e2d9cc5e2ffdd514f3","modified":1488803013173},{"_id":"public/highlightjs/school_book.css","hash":"f257d41cdca2609fa4c664df9cc14b48e2bcb09f","modified":1488803013173},{"_id":"public/highlightjs/solarized_dark.css","hash":"007f9f1e7addf7e2040734cd1f733d041432c335","modified":1488803013173},{"_id":"public/highlightjs/sunburst.css","hash":"e72bc116795505c1fcae35bc69045043fc34a243","modified":1488803013173},{"_id":"public/highlightjs/solarized_light.css","hash":"a85878fd70ecd03c71944df1acbbf320bac7979f","modified":1488803013174},{"_id":"public/highlightjs/tomorrow-night-blue.css","hash":"e2bed22abcdf3f2b8ca3a1a73624751d3edc4e64","modified":1488803013174},{"_id":"public/highlightjs/tomorrow-night-eighties.css","hash":"9603bc778de2dabd0ce1e7ee272a047338a8b99c","modified":1488803013174},{"_id":"public/highlightjs/tomorrow-night-bright.css","hash":"afdb004743a8d2b52d38c7a1fce32d631a0f3ded","modified":1488803013174},{"_id":"public/highlightjs/tomorrow-night.css","hash":"48cd18ce93daa491d89eb63e5fe3ab640ff56d74","modified":1488803013174},{"_id":"public/highlightjs/tomorrow.css","hash":"a184e23b28b6a6401ecfc35e0a94de0bada589e4","modified":1488803013174},{"_id":"public/highlightjs/xcode.css","hash":"78cb5758ce4085aa51edb6c5beb64d8f4511edd7","modified":1488803013174},{"_id":"public/highlightjs/vs.css","hash":"13e2f7ec2e197d79f4fc36768ea4a0663d41e1c0","modified":1488803013174},{"_id":"public/highlightjs/zenburn.css","hash":"73dafd21563f5fc3bb74856d4abf97c447a27772","modified":1488803013174},{"_id":"public/js/html5shiv.min.js","hash":"bb51a5f6c394989bb06e4171179354c6d05ec8f8","modified":1488803013174},{"_id":"public/js/jquery.ajaxchimp.min.js","hash":"9be17785b0d816e1cd6bc45908e1805e0522fe18","modified":1488803013174},{"_id":"public/js/respond.min.js","hash":"b5aba40d65b0d6f85859db47f757ea971a0efd30","modified":1488803013174},{"_id":"public/js/scripts.js","hash":"4e4ebd697d00d3d0fcea7cbf78f5a7312e2f22ed","modified":1488803013175},{"_id":"public/css/animsition.min.css","hash":"59033074f6594a0d87c759e2b8cf9baa3a62ed6a","modified":1488803013175},{"_id":"public/css/all.css","hash":"cec339c3bf2113fe3b3ba8932f8f5566f248abe8","modified":1488803013175},{"_id":"public/js/jquery.flexslider-min.js","hash":"51b3a7d882f438d53dc69ca5289e92254160c09a","modified":1488803013175},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1488803013175},{"_id":"public/css/style.css","hash":"3e26ab1f78440b22938b4d012b43b6d6859c35b3","modified":1488803013175},{"_id":"public/js/jquery-1.11.1.min.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1488803013175},{"_id":"public/js/plugins.min.js","hash":"5d2edd4ecc4b27af81a3255ca8a253d23fc518e1","modified":1488803013175},{"_id":"public/img/bg_img.jpg","hash":"36263c65562c7ff11bc2b973e235ebce57a7773c","modified":1488803013175},{"_id":"public/img/bg_img_bear.jpg","hash":"3dd99bb3c09798ce11837521222944570756437c","modified":1488803013177}],"Category":[{"name":"promise","_id":"cizy2vgko0003a985i8j3yzw6"},{"name":"react","_id":"cizy2vgky0008a985w727sw0x"},{"name":"yarn","_id":"cizy2vgkz000aa985t36rwxhp"},{"name":"异步编程","parent":"cizy2vgko0003a985i8j3yzw6","_id":"cizy2vgl3000ga9857h6cdigh"},{"name":"http","_id":"cizy2vgl4000ka98576q3ci4e"},{"name":"test","parent":"cizy2vgky0008a985w727sw0x","_id":"cizy2vgl5000na9850t2bd60p"},{"name":"npm","parent":"cizy2vgkz000aa985t36rwxhp","_id":"cizy2vgl6000ta985t2b83ky2"},{"name":"工具","parent":"cizy2vgl6000ta985t2b83ky2","_id":"cizy2vgl7000za985ump7f9kl"}],"Data":[],"Page":[{"title":"about","date":"2017-01-24T03:11:26.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-24 11:11:26\n---\n","updated":"2017-01-24T03:11:26.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cizy2vgki0001a985qp4ot0t3","content":"","excerpt":"","more":""}],"Post":[{"title":"Promise-JavaScript异步编程","date":"2017-03-05T06:57:24.000Z","banner":"https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg","_content":"\nPromise是异步编程的一种解决方案。\n\n### Why Promise?\nJavascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。\n\nES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。\n\n基本用法如下：\n```code\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n关于链式写法，借用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的图参考如下：\n![Promise Chain](https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png)\n\nPromise有三种状态，分别是`pending`表示初始状态；`fulfilled`(或`resolved`)表示操作成功完成；`rejected`表示操作失败。状态的改变只有2种可能，从`pending`变成`fulfilled`以及从`pending`变成`rejected`，一旦状态改变，就不会再变。\n\n<!-- more -->\n\n以Ajax为例：\n```code\nvar ajax = function(url){\n  return new Promise(function(resolve, reject){\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url, true);\n    xhr.responseType = \"json\";\n    xhr.onreadystatechange = readyStateHandle;\n    xhr.send();\n\n    function readyStateHandle(){\n      if(this.readyState !== 4) return;\n      if(this.status === 200){\n        resolve(this.response);\n      }else{\n        reject(new Error(this.statusText));\n      }\n    }\n  });\n}\n```\n\n目前Chrome、Firefox、Safari的高版本已经支持Promise。\n\n### Promise API\n#### .then()\n为Promise实例添加状态改变时的回调函数。第一个参数是`fulfilled`状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是`rejected`状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。\n\n继续上面的Ajax的例子，用法如下：\n```code\najax(\"./posts.json\").then((json) => {\n  console.log('Contents:', json);\n}, (error) => {\n  console.error('出错了', error);\n});\n```\n\n`then`方法返回的是一个新的Promise实例，因此可以使用链式写法。\n\n第一个`fulfilled`回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个`then`方法的`fulfilled`回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个string\n  return json.nextJsonUrl;\n}).then(\n  url => console.log(url),  // 得到json.nextJsonUrl对应的值，一个string\n  error => console.error('出错了', error)\n)\n```\n\n第二种是返回一个Promise对象，则第二个`then`将会等待当前状态发生变化之后再按照结果决定调用哪个回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个Promise对象\n  return ajax(json.nextJsonUrl);\n}).then(\n  nextJson => console.log(nextJson),  // 假设成功，得到第二个json的内容\n  error => console.error('出错了', error)\n)\n```\n\n#### .catch()\n`catch`方法用于指定发生错误时的回调函数，等同于`then(null, rejection)`，如下：\n```code\najax(\"./posts.json\").then(\n  json => {...}, \n  error => console.error('出错了', error)\n)\n// 等同于\najax(\"./posts.json\").then(\n  json => {...}\n).catch(\n  error => console.error('出错了', error)\n)\n```\n用`catch`能够捕获ajax()抛出的错误和`then`方法执行过程中发生的异常或错误，相对`then`用`catch`处理`rejected`状态的写法更佳。\n\n`catch`方法返回的还是一个Promise对象，因此接下去还可以继续使用`then`方法。\n```code\najax(\"./posts.json\").then(json => {\n  return ajax(json.nextJsonUrl);\n}).catch(\n  error => console.error('出错了', error)\n).then(\n  nextJson => console.log(nextJson)\n)\n```\n如果`catch`之前没有报错，则直接跳过`catch`执行下一个`then`方法，这时候这个`then`是否报错与前面的`catch`就无关了。若当前`catch`方法中抛出错误，在当前`catch`中是无法捕获的，需要在后面的`catch`方法中捕获/处理。\n\n#### .all() & .race()\n`all`方法和`race`方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过`Promise.resolve`方法转化，返回的每个成员都是Promise实例。\n\n对于`all`方法，只有所有成员都变成`fulfilled`，`promises`的状态才会变成`fulfilled`，这时的返回值组成一个数组传递给`promises`的回调函数；只要任何一个成员的状态变为`rejected`，`promises`的状态就会变成`rejected`，第一个被`rejected`的实例的返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.all([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组\n}).catch((error)=>{\n  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息\n});\n```\n\n对于`race`方法，只要其中一个成员率先改变状态，就会作为返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.race([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值\n}).catch((error)=>{\n  console.error(error); \n  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误\n});\n```\n\n#### .resolve()\n`resolve`方法用于将传入的参数转化为Promise对象。\n```code\nPromise.resolve(\"Hello World\");\n// 等同于\nnew Promise(resolve => {\n  resolve(\"Hello World\");\n})\n```\n\n传参可能有四种情况：\n- 参数是一个Promise实例：不做任何改变返回。\n- 参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。\n- 参数根本不是对象：返回一个状态为Resolved的Promise对象。\n- 不带任何参数：直接返回一个Resolved状态的Promise对象。\n\n#### .reject()\n`reject`方法会返回一个为`rejected`状态的Promise对象。\n```code\nPromise.reject(\"error!\");\n// 类似于\nnew Promise((resolve, reject) => {\n  reject(\"error!\");\n}).catch(\n  error => console.error(error) // 控制台的输出稍有不同\n)\n```\n\n`reject`方法的参数会原封不动的作为错误的返回值，如：\n```code\nPromise.reject(ajax(\"./posts.json\"));\n```\n即使已经成功获取到`posts.json`的内容，控制台仍然会输出`Uncaught (in promise) ...`。\n\n### 总结\n对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。\n\n\n参考：[ECMAScript 6入门－Promise对象](http://es6.ruanyifeng.com/#docs/promise)","source":"_posts/Promise-JavaScript异步编程.md","raw":"title: Promise-JavaScript异步编程\ndate: 2017-03-05 14:57:24\nbanner: https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg\ntags:\n- promise\n- 异步编程\n- 陈小饼\ncategories:\n- promise\n- 异步编程\n---\n\nPromise是异步编程的一种解决方案。\n\n### Why Promise?\nJavascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。\n\nES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。\n\n基本用法如下：\n```code\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n关于链式写法，借用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的图参考如下：\n![Promise Chain](https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png)\n\nPromise有三种状态，分别是`pending`表示初始状态；`fulfilled`(或`resolved`)表示操作成功完成；`rejected`表示操作失败。状态的改变只有2种可能，从`pending`变成`fulfilled`以及从`pending`变成`rejected`，一旦状态改变，就不会再变。\n\n<!-- more -->\n\n以Ajax为例：\n```code\nvar ajax = function(url){\n  return new Promise(function(resolve, reject){\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url, true);\n    xhr.responseType = \"json\";\n    xhr.onreadystatechange = readyStateHandle;\n    xhr.send();\n\n    function readyStateHandle(){\n      if(this.readyState !== 4) return;\n      if(this.status === 200){\n        resolve(this.response);\n      }else{\n        reject(new Error(this.statusText));\n      }\n    }\n  });\n}\n```\n\n目前Chrome、Firefox、Safari的高版本已经支持Promise。\n\n### Promise API\n#### .then()\n为Promise实例添加状态改变时的回调函数。第一个参数是`fulfilled`状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是`rejected`状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。\n\n继续上面的Ajax的例子，用法如下：\n```code\najax(\"./posts.json\").then((json) => {\n  console.log('Contents:', json);\n}, (error) => {\n  console.error('出错了', error);\n});\n```\n\n`then`方法返回的是一个新的Promise实例，因此可以使用链式写法。\n\n第一个`fulfilled`回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个`then`方法的`fulfilled`回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个string\n  return json.nextJsonUrl;\n}).then(\n  url => console.log(url),  // 得到json.nextJsonUrl对应的值，一个string\n  error => console.error('出错了', error)\n)\n```\n\n第二种是返回一个Promise对象，则第二个`then`将会等待当前状态发生变化之后再按照结果决定调用哪个回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个Promise对象\n  return ajax(json.nextJsonUrl);\n}).then(\n  nextJson => console.log(nextJson),  // 假设成功，得到第二个json的内容\n  error => console.error('出错了', error)\n)\n```\n\n#### .catch()\n`catch`方法用于指定发生错误时的回调函数，等同于`then(null, rejection)`，如下：\n```code\najax(\"./posts.json\").then(\n  json => {...}, \n  error => console.error('出错了', error)\n)\n// 等同于\najax(\"./posts.json\").then(\n  json => {...}\n).catch(\n  error => console.error('出错了', error)\n)\n```\n用`catch`能够捕获ajax()抛出的错误和`then`方法执行过程中发生的异常或错误，相对`then`用`catch`处理`rejected`状态的写法更佳。\n\n`catch`方法返回的还是一个Promise对象，因此接下去还可以继续使用`then`方法。\n```code\najax(\"./posts.json\").then(json => {\n  return ajax(json.nextJsonUrl);\n}).catch(\n  error => console.error('出错了', error)\n).then(\n  nextJson => console.log(nextJson)\n)\n```\n如果`catch`之前没有报错，则直接跳过`catch`执行下一个`then`方法，这时候这个`then`是否报错与前面的`catch`就无关了。若当前`catch`方法中抛出错误，在当前`catch`中是无法捕获的，需要在后面的`catch`方法中捕获/处理。\n\n#### .all() & .race()\n`all`方法和`race`方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过`Promise.resolve`方法转化，返回的每个成员都是Promise实例。\n\n对于`all`方法，只有所有成员都变成`fulfilled`，`promises`的状态才会变成`fulfilled`，这时的返回值组成一个数组传递给`promises`的回调函数；只要任何一个成员的状态变为`rejected`，`promises`的状态就会变成`rejected`，第一个被`rejected`的实例的返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.all([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组\n}).catch((error)=>{\n  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息\n});\n```\n\n对于`race`方法，只要其中一个成员率先改变状态，就会作为返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.race([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值\n}).catch((error)=>{\n  console.error(error); \n  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误\n});\n```\n\n#### .resolve()\n`resolve`方法用于将传入的参数转化为Promise对象。\n```code\nPromise.resolve(\"Hello World\");\n// 等同于\nnew Promise(resolve => {\n  resolve(\"Hello World\");\n})\n```\n\n传参可能有四种情况：\n- 参数是一个Promise实例：不做任何改变返回。\n- 参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。\n- 参数根本不是对象：返回一个状态为Resolved的Promise对象。\n- 不带任何参数：直接返回一个Resolved状态的Promise对象。\n\n#### .reject()\n`reject`方法会返回一个为`rejected`状态的Promise对象。\n```code\nPromise.reject(\"error!\");\n// 类似于\nnew Promise((resolve, reject) => {\n  reject(\"error!\");\n}).catch(\n  error => console.error(error) // 控制台的输出稍有不同\n)\n```\n\n`reject`方法的参数会原封不动的作为错误的返回值，如：\n```code\nPromise.reject(ajax(\"./posts.json\"));\n```\n即使已经成功获取到`posts.json`的内容，控制台仍然会输出`Uncaught (in promise) ...`。\n\n### 总结\n对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。\n\n\n参考：[ECMAScript 6入门－Promise对象](http://es6.ruanyifeng.com/#docs/promise)","slug":"Promise-JavaScript异步编程","published":1,"updated":"2017-03-06T12:23:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizy2vgkd0000a98594voypnj","content":"<p>Promise是异步编程的一种解决方案。</p>\n<h3 id=\"Why_Promise_3F\"><a href=\"#Why_Promise_3F\" class=\"headerlink\" title=\"Why Promise?\"></a>Why Promise?</h3><p>Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。</p>\n<p>ES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。</p>\n<p>基本用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>关于链式写法，借用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">MDN</a>的图参考如下：<br><img src=\"https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png\" alt=\"Promise Chain\"></p>\n<p>Promise有三种状态，分别是<code>pending</code>表示初始状态；<code>fulfilled</code>(或<code>resolved</code>)表示操作成功完成；<code>rejected</code>表示操作失败。状态的改变只有2种可能，从<code>pending</code>变成<code>fulfilled</code>以及从<code>pending</code>变成<code>rejected</code>，一旦状态改变，就不会再变。</p>\n<a id=\"more\"></a>\n<p>以Ajax为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ajax = function(url)&#123;</div><div class=\"line\">  return new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.responseType = &quot;json&quot;;</div><div class=\"line\">    xhr.onreadystatechange = readyStateHandle;</div><div class=\"line\">    xhr.send();</div><div class=\"line\"></div><div class=\"line\">    function readyStateHandle()&#123;</div><div class=\"line\">      if(this.readyState !== 4) return;</div><div class=\"line\">      if(this.status === 200)&#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>目前Chrome、Firefox、Safari的高版本已经支持Promise。</p>\n<h3 id=\"Promise_API\"><a href=\"#Promise_API\" class=\"headerlink\" title=\"Promise API\"></a>Promise API</h3><h4 id=\"then_28_29\"><a href=\"#then_28_29\" class=\"headerlink\" title=\".then()\"></a>.then()</h4><p>为Promise实例添加状态改变时的回调函数。第一个参数是<code>fulfilled</code>状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是<code>rejected</code>状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。</p>\n<p>继续上面的Ajax的例子，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then((json) =&gt; &#123;</div><div class=\"line\">  console.log(&apos;Contents:&apos;, json);</div><div class=\"line\">&#125;, (error) =&gt; &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法返回的是一个新的Promise实例，因此可以使用链式写法。</p>\n<p>第一个<code>fulfilled</code>回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个<code>then</code>方法的<code>fulfilled</code>回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个string</div><div class=\"line\">  return json.nextJsonUrl;</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  url =&gt; console.log(url),  // 得到json.nextJsonUrl对应的值，一个string</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>第二种是返回一个Promise对象，则第二个<code>then</code>将会等待当前状态发生变化之后再按照结果决定调用哪个回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个Promise对象</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson),  // 假设成功，得到第二个json的内容</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h4 id=\"catch_28_29\"><a href=\"#catch_28_29\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h4><p><code>catch</code>方法用于指定发生错误时的回调函数，等同于<code>then(null, rejection)</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;, </div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div><div class=\"line\">// 等同于</div><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>用<code>catch</code>能够捕获ajax()抛出的错误和<code>then</code>方法执行过程中发生的异常或错误，相对<code>then</code>用<code>catch</code>处理<code>rejected</code>状态的写法更佳。</p>\n<p><code>catch</code>方法返回的还是一个Promise对象，因此接下去还可以继续使用<code>then</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>如果<code>catch</code>之前没有报错，则直接跳过<code>catch</code>执行下一个<code>then</code>方法，这时候这个<code>then</code>是否报错与前面的<code>catch</code>就无关了。若当前<code>catch</code>方法中抛出错误，在当前<code>catch</code>中是无法捕获的，需要在后面的<code>catch</code>方法中捕获/处理。</p>\n<h4 id=\"all_28_29__26amp_3B_-race_28_29\"><a href=\"#all_28_29__26amp_3B_-race_28_29\" class=\"headerlink\" title=\".all() &amp; .race()\"></a>.all() &amp; .race()</h4><p><code>all</code>方法和<code>race</code>方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过<code>Promise.resolve</code>方法转化，返回的每个成员都是Promise实例。</p>\n<p>对于<code>all</code>方法，只有所有成员都变成<code>fulfilled</code>，<code>promises</code>的状态才会变成<code>fulfilled</code>，这时的返回值组成一个数组传递给<code>promises</code>的回调函数；只要任何一个成员的状态变为<code>rejected</code>，<code>promises</code>的状态就会变成<code>rejected</code>，第一个被<code>rejected</code>的实例的返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.all([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>race</code>方法，只要其中一个成员率先改变状态，就会作为返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.race([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); </div><div class=\"line\">  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"resolve_28_29\"><a href=\"#resolve_28_29\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h4><p><code>resolve</code>方法用于将传入的参数转化为Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.resolve(&quot;Hello World&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">new Promise(resolve =&gt; &#123;</div><div class=\"line\">  resolve(&quot;Hello World&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>传参可能有四种情况：</p>\n<ul>\n<li>参数是一个Promise实例：不做任何改变返回。</li>\n<li>参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。</li>\n<li>参数根本不是对象：返回一个状态为Resolved的Promise对象。</li>\n<li>不带任何参数：直接返回一个Resolved状态的Promise对象。</li>\n</ul>\n<h4 id=\"reject_28_29\"><a href=\"#reject_28_29\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h4><p><code>reject</code>方法会返回一个为<code>rejected</code>状态的Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(&quot;error!&quot;);</div><div class=\"line\">// 类似于</div><div class=\"line\">new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">  reject(&quot;error!&quot;);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(error) // 控制台的输出稍有不同</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p><code>reject</code>方法的参数会原封不动的作为错误的返回值，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(ajax(&quot;./posts.json&quot;));</div></pre></td></tr></table></figure></p>\n<p>即使已经成功获取到<code>posts.json</code>的内容，控制台仍然会输出<code>Uncaught (in promise) ...</code>。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。</p>\n<p>参考：<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">ECMAScript 6入门－Promise对象</a></p>\n","excerpt":"<p>Promise是异步编程的一种解决方案。</p>\n<h3 id=\"Why_Promise_3F\"><a href=\"#Why_Promise_3F\" class=\"headerlink\" title=\"Why Promise?\"></a>Why Promise?</h3><p>Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。</p>\n<p>ES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。</p>\n<p>基本用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>关于链式写法，借用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN</a>的图参考如下：<br><img src=\"https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png\" alt=\"Promise Chain\"></p>\n<p>Promise有三种状态，分别是<code>pending</code>表示初始状态；<code>fulfilled</code>(或<code>resolved</code>)表示操作成功完成；<code>rejected</code>表示操作失败。状态的改变只有2种可能，从<code>pending</code>变成<code>fulfilled</code>以及从<code>pending</code>变成<code>rejected</code>，一旦状态改变，就不会再变。</p>","more":"<p>以Ajax为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ajax = function(url)&#123;</div><div class=\"line\">  return new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.responseType = &quot;json&quot;;</div><div class=\"line\">    xhr.onreadystatechange = readyStateHandle;</div><div class=\"line\">    xhr.send();</div><div class=\"line\"></div><div class=\"line\">    function readyStateHandle()&#123;</div><div class=\"line\">      if(this.readyState !== 4) return;</div><div class=\"line\">      if(this.status === 200)&#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>目前Chrome、Firefox、Safari的高版本已经支持Promise。</p>\n<h3 id=\"Promise_API\"><a href=\"#Promise_API\" class=\"headerlink\" title=\"Promise API\"></a>Promise API</h3><h4 id=\"then_28_29\"><a href=\"#then_28_29\" class=\"headerlink\" title=\".then()\"></a>.then()</h4><p>为Promise实例添加状态改变时的回调函数。第一个参数是<code>fulfilled</code>状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是<code>rejected</code>状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。</p>\n<p>继续上面的Ajax的例子，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then((json) =&gt; &#123;</div><div class=\"line\">  console.log(&apos;Contents:&apos;, json);</div><div class=\"line\">&#125;, (error) =&gt; &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法返回的是一个新的Promise实例，因此可以使用链式写法。</p>\n<p>第一个<code>fulfilled</code>回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个<code>then</code>方法的<code>fulfilled</code>回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个string</div><div class=\"line\">  return json.nextJsonUrl;</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  url =&gt; console.log(url),  // 得到json.nextJsonUrl对应的值，一个string</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>第二种是返回一个Promise对象，则第二个<code>then</code>将会等待当前状态发生变化之后再按照结果决定调用哪个回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个Promise对象</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson),  // 假设成功，得到第二个json的内容</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h4 id=\"catch_28_29\"><a href=\"#catch_28_29\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h4><p><code>catch</code>方法用于指定发生错误时的回调函数，等同于<code>then(null, rejection)</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;, </div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div><div class=\"line\">// 等同于</div><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>用<code>catch</code>能够捕获ajax()抛出的错误和<code>then</code>方法执行过程中发生的异常或错误，相对<code>then</code>用<code>catch</code>处理<code>rejected</code>状态的写法更佳。</p>\n<p><code>catch</code>方法返回的还是一个Promise对象，因此接下去还可以继续使用<code>then</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>如果<code>catch</code>之前没有报错，则直接跳过<code>catch</code>执行下一个<code>then</code>方法，这时候这个<code>then</code>是否报错与前面的<code>catch</code>就无关了。若当前<code>catch</code>方法中抛出错误，在当前<code>catch</code>中是无法捕获的，需要在后面的<code>catch</code>方法中捕获/处理。</p>\n<h4 id=\"all_28_29__26amp_3B_-race_28_29\"><a href=\"#all_28_29__26amp_3B_-race_28_29\" class=\"headerlink\" title=\".all() &amp; .race()\"></a>.all() &amp; .race()</h4><p><code>all</code>方法和<code>race</code>方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过<code>Promise.resolve</code>方法转化，返回的每个成员都是Promise实例。</p>\n<p>对于<code>all</code>方法，只有所有成员都变成<code>fulfilled</code>，<code>promises</code>的状态才会变成<code>fulfilled</code>，这时的返回值组成一个数组传递给<code>promises</code>的回调函数；只要任何一个成员的状态变为<code>rejected</code>，<code>promises</code>的状态就会变成<code>rejected</code>，第一个被<code>rejected</code>的实例的返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.all([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>race</code>方法，只要其中一个成员率先改变状态，就会作为返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.race([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); </div><div class=\"line\">  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"resolve_28_29\"><a href=\"#resolve_28_29\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h4><p><code>resolve</code>方法用于将传入的参数转化为Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.resolve(&quot;Hello World&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">new Promise(resolve =&gt; &#123;</div><div class=\"line\">  resolve(&quot;Hello World&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>传参可能有四种情况：</p>\n<ul>\n<li>参数是一个Promise实例：不做任何改变返回。</li>\n<li>参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。</li>\n<li>参数根本不是对象：返回一个状态为Resolved的Promise对象。</li>\n<li>不带任何参数：直接返回一个Resolved状态的Promise对象。</li>\n</ul>\n<h4 id=\"reject_28_29\"><a href=\"#reject_28_29\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h4><p><code>reject</code>方法会返回一个为<code>rejected</code>状态的Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(&quot;error!&quot;);</div><div class=\"line\">// 类似于</div><div class=\"line\">new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">  reject(&quot;error!&quot;);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(error) // 控制台的输出稍有不同</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p><code>reject</code>方法的参数会原封不动的作为错误的返回值，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(ajax(&quot;./posts.json&quot;));</div></pre></td></tr></table></figure></p>\n<p>即使已经成功获取到<code>posts.json</code>的内容，控制台仍然会输出<code>Uncaught (in promise) ...</code>。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。</p>\n<p>参考：<a href=\"http://es6.ruanyifeng.com/#docs/promise\">ECMAScript 6入门－Promise对象</a></p>"},{"title":"React组件单元测试","date":"2017-01-18T03:25:02.000Z","banner":"https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg","_content":"\n针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\n\n### Test Utilities\n#### Shallow Rendering - 浅渲染\nShallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。\n<!-- more -->\n函数shallowRender返回浅渲染的虚拟DOM对象：\n```code\nimport TestUtils from 'react/lib/ReactTestUtils.js';\n\nfunction shallowRender(Component, props){\n    const renderer = TestUtils.createRenderer();\n    renderer.render(<Component {...props}/>);\n    return renderer.getRenderOutput();\n}\n```\n浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：\n```code\nimport React from 'react';\nimport assert from 'assert';\nimport Button from '../src/Button';\n\ndescribe(\"<Button/>\", function(){\n    it('phStyle设置为primary', ()=>{\n        const button = shallowRender(<Button phStyle='primary'></Button>);\n        assert(button.props.className.match('primary'));\n    });\n});\n```\n\n#### renderIntoDocument - 将element渲染成真实的DOM节点\nrenderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：\n```code\n// ...\nimport {findDOMNode} from 'react-dom';\nimport Switch from '../src/Switch';\n\ndescribe(\"<Switch/>\", function(){\n    it('改变时触发onChange', ()=>{\n        let checked = true;\n        const switchs = TestUtils.renderIntoDocument(<Switch checked={checked} onChange={()=>{checked=false}} />);\n        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, 'input')[0];\n\n        TestUtils.Simulate.change(checkbox);\n        assert.equal(checked, false);\n    });\n});\n```\n初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。\n\n#### Simulate - 模拟用户操作\n`Simulate.{eventName}(element,[eventData])`将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。\n```code\nTestUtils.Simulate.click(node);\nTestUtils.Simulate.change(node);\nTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n```\n\n#### 节点查找\nTest Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对`props.children`进行查找。\n##### 虚拟DOM的节点查找\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallowRender(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.props.children[1].props.children, label);\n});\n// ...\n```\n`checkbox.props.children[1].props.children`查找的是第二个子元素的内容。\n\n##### 真实DOM的节点查找\n对于真实DOM节点，可以是JavaScript原生的一些方法，如`findDOMNode(node).querySelector(...)`。以下是Test Utilities提供的方法：\n-   scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点\n-   findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点\n-   findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedComponentsWithType：找出所有符合指定子组件的节点\n-   findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点\n\n更多信息：[Test Utilities](https://facebook.github.io/react/docs/test-utils.html)\n\n### Enzyme\nEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。\n#### 使用\n正式使用前有几点需要注意，否则会报错。\n-   首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：\n\t```code\n\t/* webpack.config.js for React 0.14 */\n\t// ...\n\texternals: {\n\t  'cheerio': 'window',\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n\t```code\n\t/* webpack.config.js for React 15 */\n\t// ...\n\texternals: {\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n更多信息：[enzyme-guides](http://airbnb.io/enzyme/docs/guides/webpack.html)\n\n-   针对不同版本React的安装\n\t```code\n\t/* React 0.13 */\n\tnpm i react@0.13 --save\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 0.14 */\n\tnpm i --save react@0.14 react-dom@0.14\n\tnpm i --save-dev react-addons-test-utils@0.14\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 15 */\n\tnpm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2\n\tnpm i --save-dev react-addons-test-utils@15.0.0-rc.2\n\tnpm i --save-dev enzyme\n\t```\n更多信息：[enzyme-installation](http://airbnb.io/enzyme/docs/installation/index.html)\n\n#### API\n##### shallow\nshallow方法是对Shallow Rendering的封装，同一个例子，获取`className`的方法通过`props()`方法返回。\n```code\n// ...\nit('phStyle设置为primary', ()=>{\n    const button = shallow(<Button phStyle='primary'>btn</Button>);\n    assert(button.props().className.match('primary'));\n});\n// ...\n```\n同一个例子，使用`find()`方法查找子节点，`text()`方法获取文本内容。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallow(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n\n##### mount\nmount将React组件加载为真实的DOM节点。和shallow的api相同，用`find()`方法查找子节点，模拟用户操作的方法封装为`simulate(enentType)`。\n```code\n// ...\nit('改变时触发onChange', ()=>{\n    let checked = true;\n    const switchs = mount(<Switch checked={checked} onChange={()=>{checked=false}} />);\n    \n    switchs.find('input').simulate('change');\n    assert.equal(checked, false);\n});\n// ...\n```\n\n##### render\nrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = render(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n使用render方法时碰到一个错误：`_cheerio2.default.load is not a function`，还是比较普遍的，跟webpack配置有关系，修改如下：\n```code\nexternals: {\n        'jsdom': 'window',\n        // 'cheerio': 'window',\n        // ...\n    },\n    module:{\n        loaders:[\n            // ...\n            {\n                test: /\\.json$/,\n                loader: 'json',\n            }\n        ]\n    }\n```\n\n更多信息：[enzyme-api](http://airbnb.io/enzyme/docs/api/index.html)\n\n### 其他\n#### Jest\nJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。\n> Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.\n\n普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。\n\n更多信息：[jest-react-tutorial](https://facebook.github.io/jest/docs/tutorial-react.html)\n\n### 总结\n其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄\n\n","source":"_posts/React组件单元测试.md","raw":"---\ntitle: React组件单元测试\ndate: 2017-01-18 11:25:02\nbanner: https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg\ntags:\n- react\n- test\n- 陈小饼\ncategories:\n- react\n- test\n---\n\n针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\n\n### Test Utilities\n#### Shallow Rendering - 浅渲染\nShallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。\n<!-- more -->\n函数shallowRender返回浅渲染的虚拟DOM对象：\n```code\nimport TestUtils from 'react/lib/ReactTestUtils.js';\n\nfunction shallowRender(Component, props){\n    const renderer = TestUtils.createRenderer();\n    renderer.render(<Component {...props}/>);\n    return renderer.getRenderOutput();\n}\n```\n浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：\n```code\nimport React from 'react';\nimport assert from 'assert';\nimport Button from '../src/Button';\n\ndescribe(\"<Button/>\", function(){\n    it('phStyle设置为primary', ()=>{\n        const button = shallowRender(<Button phStyle='primary'></Button>);\n        assert(button.props.className.match('primary'));\n    });\n});\n```\n\n#### renderIntoDocument - 将element渲染成真实的DOM节点\nrenderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：\n```code\n// ...\nimport {findDOMNode} from 'react-dom';\nimport Switch from '../src/Switch';\n\ndescribe(\"<Switch/>\", function(){\n    it('改变时触发onChange', ()=>{\n        let checked = true;\n        const switchs = TestUtils.renderIntoDocument(<Switch checked={checked} onChange={()=>{checked=false}} />);\n        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, 'input')[0];\n\n        TestUtils.Simulate.change(checkbox);\n        assert.equal(checked, false);\n    });\n});\n```\n初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。\n\n#### Simulate - 模拟用户操作\n`Simulate.{eventName}(element,[eventData])`将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。\n```code\nTestUtils.Simulate.click(node);\nTestUtils.Simulate.change(node);\nTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n```\n\n#### 节点查找\nTest Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对`props.children`进行查找。\n##### 虚拟DOM的节点查找\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallowRender(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.props.children[1].props.children, label);\n});\n// ...\n```\n`checkbox.props.children[1].props.children`查找的是第二个子元素的内容。\n\n##### 真实DOM的节点查找\n对于真实DOM节点，可以是JavaScript原生的一些方法，如`findDOMNode(node).querySelector(...)`。以下是Test Utilities提供的方法：\n-   scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点\n-   findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点\n-   findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedComponentsWithType：找出所有符合指定子组件的节点\n-   findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点\n\n更多信息：[Test Utilities](https://facebook.github.io/react/docs/test-utils.html)\n\n### Enzyme\nEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。\n#### 使用\n正式使用前有几点需要注意，否则会报错。\n-   首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：\n\t```code\n\t/* webpack.config.js for React 0.14 */\n\t// ...\n\texternals: {\n\t  'cheerio': 'window',\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n\t```code\n\t/* webpack.config.js for React 15 */\n\t// ...\n\texternals: {\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n更多信息：[enzyme-guides](http://airbnb.io/enzyme/docs/guides/webpack.html)\n\n-   针对不同版本React的安装\n\t```code\n\t/* React 0.13 */\n\tnpm i react@0.13 --save\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 0.14 */\n\tnpm i --save react@0.14 react-dom@0.14\n\tnpm i --save-dev react-addons-test-utils@0.14\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 15 */\n\tnpm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2\n\tnpm i --save-dev react-addons-test-utils@15.0.0-rc.2\n\tnpm i --save-dev enzyme\n\t```\n更多信息：[enzyme-installation](http://airbnb.io/enzyme/docs/installation/index.html)\n\n#### API\n##### shallow\nshallow方法是对Shallow Rendering的封装，同一个例子，获取`className`的方法通过`props()`方法返回。\n```code\n// ...\nit('phStyle设置为primary', ()=>{\n    const button = shallow(<Button phStyle='primary'>btn</Button>);\n    assert(button.props().className.match('primary'));\n});\n// ...\n```\n同一个例子，使用`find()`方法查找子节点，`text()`方法获取文本内容。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallow(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n\n##### mount\nmount将React组件加载为真实的DOM节点。和shallow的api相同，用`find()`方法查找子节点，模拟用户操作的方法封装为`simulate(enentType)`。\n```code\n// ...\nit('改变时触发onChange', ()=>{\n    let checked = true;\n    const switchs = mount(<Switch checked={checked} onChange={()=>{checked=false}} />);\n    \n    switchs.find('input').simulate('change');\n    assert.equal(checked, false);\n});\n// ...\n```\n\n##### render\nrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = render(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n使用render方法时碰到一个错误：`_cheerio2.default.load is not a function`，还是比较普遍的，跟webpack配置有关系，修改如下：\n```code\nexternals: {\n        'jsdom': 'window',\n        // 'cheerio': 'window',\n        // ...\n    },\n    module:{\n        loaders:[\n            // ...\n            {\n                test: /\\.json$/,\n                loader: 'json',\n            }\n        ]\n    }\n```\n\n更多信息：[enzyme-api](http://airbnb.io/enzyme/docs/api/index.html)\n\n### 其他\n#### Jest\nJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。\n> Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.\n\n普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。\n\n更多信息：[jest-react-tutorial](https://facebook.github.io/jest/docs/tutorial-react.html)\n\n### 总结\n其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄\n\n","slug":"React组件单元测试","published":1,"updated":"2017-01-24T07:41:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizy2vgkl0002a985g31fnull","content":"<p>针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。</p>\n<h3 id=\"Test_Utilities\"><a href=\"#Test_Utilities\" class=\"headerlink\" title=\"Test Utilities\"></a>Test Utilities</h3><h4 id=\"Shallow_Rendering_-__u6D45_u6E32_u67D3\"><a href=\"#Shallow_Rendering_-__u6D45_u6E32_u67D3\" class=\"headerlink\" title=\"Shallow Rendering - 浅渲染\"></a>Shallow Rendering - 浅渲染</h4><p>Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。<br><a id=\"more\"></a><br>函数shallowRender返回浅渲染的虚拟DOM对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;</div><div class=\"line\"></div><div class=\"line\">function shallowRender(Component, props)&#123;</div><div class=\"line\">    const renderer = TestUtils.createRenderer();</div><div class=\"line\">    renderer.render(&lt;Component &#123;...props&#125;/&gt;);</div><div class=\"line\">    return renderer.getRenderOutput();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React from &apos;react&apos;;</div><div class=\"line\">import assert from &apos;assert&apos;;</div><div class=\"line\">import Button from &apos;../src/Button&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Button/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">        const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;);</div><div class=\"line\">        assert(button.props.className.match(&apos;primary&apos;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\"><a href=\"#renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\" class=\"headerlink\" title=\"renderIntoDocument - 将element渲染成真实的DOM节点\"></a>renderIntoDocument - 将element渲染成真实的DOM节点</h4><p>renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">import &#123;findDOMNode&#125; from &apos;react-dom&apos;;</div><div class=\"line\">import Switch from &apos;../src/Switch&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Switch/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">        let checked = true;</div><div class=\"line\">        const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0];</div><div class=\"line\"></div><div class=\"line\">        TestUtils.Simulate.change(checkbox);</div><div class=\"line\">        assert.equal(checked, false);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。</p>\n<h4 id=\"Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\"><a href=\"#Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\" class=\"headerlink\" title=\"Simulate - 模拟用户操作\"></a>Simulate - 模拟用户操作</h4><p><code>Simulate.{eventName}(element,[eventData])</code>将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestUtils.Simulate.click(node);</div><div class=\"line\">TestUtils.Simulate.change(node);</div><div class=\"line\">TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"u8282_u70B9_u67E5_u627E\"><a href=\"#u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"节点查找\"></a>节点查找</h4><p>Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对<code>props.children</code>进行查找。</p>\n<h5 id=\"u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"虚拟DOM的节点查找\"></a>虚拟DOM的节点查找</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.props.children[1].props.children, label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<p><code>checkbox.props.children[1].props.children</code>查找的是第二个子元素的内容。</p>\n<h5 id=\"u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"真实DOM的节点查找\"></a>真实DOM的节点查找</h5><p>对于真实DOM节点，可以是JavaScript原生的一些方法，如<code>findDOMNode(node).querySelector(...)</code>。以下是Test Utilities提供的方法：</p>\n<ul>\n<li>scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点</li>\n<li>findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点</li>\n<li>findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedComponentsWithType：找出所有符合指定子组件的节点</li>\n<li>findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点</li>\n</ul>\n<p>更多信息：<a href=\"https://facebook.github.io/react/docs/test-utils.html\" target=\"_blank\" rel=\"external\">Test Utilities</a></p>\n<h3 id=\"Enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h3><p>Enzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。</p>\n<h4 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>正式使用前有几点需要注意，否则会报错。</p>\n<ul>\n<li><p>首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 0.14 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 15 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/guides/webpack.html\" target=\"_blank\" rel=\"external\">enzyme-guides</a></p>\n<ul>\n<li><p>针对不同版本React的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.13 */</div><div class=\"line\">npm i react@0.13 --save</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.14 */</div><div class=\"line\">npm i --save react@0.14 react-dom@0.14</div><div class=\"line\">npm i --save-dev react-addons-test-utils@0.14</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 15 */</div><div class=\"line\">npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev react-addons-test-utils@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/installation/index.html\" target=\"_blank\" rel=\"external\">enzyme-installation</a></p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><h5 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h5><p>shallow方法是对Shallow Rendering的封装，同一个例子，获取<code>className</code>的方法通过<code>props()</code>方法返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">    const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;);</div><div class=\"line\">    assert(button.props().className.match(&apos;primary&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>同一个例子，使用<code>find()</code>方法查找子节点，<code>text()</code>方法获取文本内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h5><p>mount将React组件加载为真实的DOM节点。和shallow的api相同，用<code>find()</code>方法查找子节点，模拟用户操作的方法封装为<code>simulate(enentType)</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">    let checked = true;</div><div class=\"line\">    const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">    </div><div class=\"line\">    switchs.find(&apos;input&apos;).simulate(&apos;change&apos;);</div><div class=\"line\">    assert.equal(checked, false);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>render方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>使用render方法时碰到一个错误：<code>_cheerio2.default.load is not a function</code>，还是比较普遍的，跟webpack配置有关系，修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">        &apos;jsdom&apos;: &apos;window&apos;,</div><div class=\"line\">        // &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module:&#123;</div><div class=\"line\">        loaders:[</div><div class=\"line\">            // ...</div><div class=\"line\">            &#123;</div><div class=\"line\">                test: /\\.json$/,</div><div class=\"line\">                loader: &apos;json&apos;,</div><div class=\"line\">            &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/api/index.html\" target=\"_blank\" rel=\"external\">enzyme-api</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。</p>\n<blockquote>\n<p>Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.</p>\n</blockquote>\n<p>普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。</p>\n<p>更多信息：<a href=\"https://facebook.github.io/jest/docs/tutorial-react.html\" target=\"_blank\" rel=\"external\">jest-react-tutorial</a></p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄</p>\n","excerpt":"<p>针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。</p>\n<h3 id=\"Test_Utilities\"><a href=\"#Test_Utilities\" class=\"headerlink\" title=\"Test Utilities\"></a>Test Utilities</h3><h4 id=\"Shallow_Rendering_-__u6D45_u6E32_u67D3\"><a href=\"#Shallow_Rendering_-__u6D45_u6E32_u67D3\" class=\"headerlink\" title=\"Shallow Rendering - 浅渲染\"></a>Shallow Rendering - 浅渲染</h4><p>Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。<br>","more":"<br>函数shallowRender返回浅渲染的虚拟DOM对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;</div><div class=\"line\"></div><div class=\"line\">function shallowRender(Component, props)&#123;</div><div class=\"line\">    const renderer = TestUtils.createRenderer();</div><div class=\"line\">    renderer.render(&lt;Component &#123;...props&#125;/&gt;);</div><div class=\"line\">    return renderer.getRenderOutput();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React from &apos;react&apos;;</div><div class=\"line\">import assert from &apos;assert&apos;;</div><div class=\"line\">import Button from &apos;../src/Button&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Button/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">        const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;);</div><div class=\"line\">        assert(button.props.className.match(&apos;primary&apos;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\"><a href=\"#renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\" class=\"headerlink\" title=\"renderIntoDocument - 将element渲染成真实的DOM节点\"></a>renderIntoDocument - 将element渲染成真实的DOM节点</h4><p>renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">import &#123;findDOMNode&#125; from &apos;react-dom&apos;;</div><div class=\"line\">import Switch from &apos;../src/Switch&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Switch/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">        let checked = true;</div><div class=\"line\">        const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0];</div><div class=\"line\"></div><div class=\"line\">        TestUtils.Simulate.change(checkbox);</div><div class=\"line\">        assert.equal(checked, false);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。</p>\n<h4 id=\"Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\"><a href=\"#Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\" class=\"headerlink\" title=\"Simulate - 模拟用户操作\"></a>Simulate - 模拟用户操作</h4><p><code>Simulate.{eventName}(element,[eventData])</code>将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestUtils.Simulate.click(node);</div><div class=\"line\">TestUtils.Simulate.change(node);</div><div class=\"line\">TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"u8282_u70B9_u67E5_u627E\"><a href=\"#u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"节点查找\"></a>节点查找</h4><p>Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对<code>props.children</code>进行查找。</p>\n<h5 id=\"u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"虚拟DOM的节点查找\"></a>虚拟DOM的节点查找</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.props.children[1].props.children, label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<p><code>checkbox.props.children[1].props.children</code>查找的是第二个子元素的内容。</p>\n<h5 id=\"u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"真实DOM的节点查找\"></a>真实DOM的节点查找</h5><p>对于真实DOM节点，可以是JavaScript原生的一些方法，如<code>findDOMNode(node).querySelector(...)</code>。以下是Test Utilities提供的方法：</p>\n<ul>\n<li>scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点</li>\n<li>findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点</li>\n<li>findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedComponentsWithType：找出所有符合指定子组件的节点</li>\n<li>findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点</li>\n</ul>\n<p>更多信息：<a href=\"https://facebook.github.io/react/docs/test-utils.html\">Test Utilities</a></p>\n<h3 id=\"Enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h3><p>Enzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。</p>\n<h4 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>正式使用前有几点需要注意，否则会报错。</p>\n<ul>\n<li><p>首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 0.14 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 15 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/guides/webpack.html\">enzyme-guides</a></p>\n<ul>\n<li><p>针对不同版本React的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.13 */</div><div class=\"line\">npm i react@0.13 --save</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.14 */</div><div class=\"line\">npm i --save react@0.14 react-dom@0.14</div><div class=\"line\">npm i --save-dev react-addons-test-utils@0.14</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 15 */</div><div class=\"line\">npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev react-addons-test-utils@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/installation/index.html\">enzyme-installation</a></p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><h5 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h5><p>shallow方法是对Shallow Rendering的封装，同一个例子，获取<code>className</code>的方法通过<code>props()</code>方法返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">    const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;);</div><div class=\"line\">    assert(button.props().className.match(&apos;primary&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>同一个例子，使用<code>find()</code>方法查找子节点，<code>text()</code>方法获取文本内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h5><p>mount将React组件加载为真实的DOM节点。和shallow的api相同，用<code>find()</code>方法查找子节点，模拟用户操作的方法封装为<code>simulate(enentType)</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">    let checked = true;</div><div class=\"line\">    const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">    </div><div class=\"line\">    switchs.find(&apos;input&apos;).simulate(&apos;change&apos;);</div><div class=\"line\">    assert.equal(checked, false);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>render方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>使用render方法时碰到一个错误：<code>_cheerio2.default.load is not a function</code>，还是比较普遍的，跟webpack配置有关系，修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">        &apos;jsdom&apos;: &apos;window&apos;,</div><div class=\"line\">        // &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module:&#123;</div><div class=\"line\">        loaders:[</div><div class=\"line\">            // ...</div><div class=\"line\">            &#123;</div><div class=\"line\">                test: /\\.json$/,</div><div class=\"line\">                loader: &apos;json&apos;,</div><div class=\"line\">            &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/api/index.html\">enzyme-api</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。</p>\n<blockquote>\n<p>Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.</p>\n</blockquote>\n<p>普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。</p>\n<p>更多信息：<a href=\"https://facebook.github.io/jest/docs/tutorial-react.html\">jest-react-tutorial</a></p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄</p>"},{"title":"Yarn-模块管理工具","date":"2017-01-11T11:39:50.000Z","banner":"https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg","_content":"\n### 简介\n2016年10月11日，facebook发布新的模块管理工具Yarn。   \n随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n-   安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n-   允许安装packages时执行代码，埋下安全隐患。\n-   安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。\n<!-- more -->\n\n### Yarn vs NPM\n#### yarn.lock\nNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：\n\n-   指定版本号（1.2.2）：只安装指定版本\n-   波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）\n-   插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）\n\n当执行`npm install [package] --save`时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。\n\nyarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的`npm-shrinkwrap.json`，需要通过执行 `npm shrinkwrap` 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。\n\n#### 更快的模块下载\nyarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。\n\n以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）\n\n除此，yarn还支持离线下载，前提是之前下过这个包。\n\n对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：\n```code\n$ yarn config set registry 'https://registry.npm.taobao.org'\n```\n\n#### 更简洁的输出\nyarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。\n\n更多信息：[migrating-from-npm](https://yarnpkg.com/en/docs/migrating-from-npm)\n\n\n### 使用\n#### 安装\n```code\n// 用Homebrew安装\n$ brew update\n$ brew install yarn\n\n// 用NPM安装\n$ npm install yarn -g\n```\n\n#### CLI\n##### 安装依赖\n安装package.json的依赖\n```code\n$ yarn\nor\n$ yarn install\n```\n\n本地安装某个模块依赖\n```code\n$ yarn add [package] \n->$ npm install [package] --save\n\n$ yarn add [package] [--dev/-D]\n->$ npm install --save-dev [package]\n```\n\n全局安装\n```code\n$ yarn global add [package]\n->$ npm install [--global/-g] [package]\n```\n\n##### 删除依赖\n```code\n$ yarn remove [package]\n->$ npm uninstall --save [package]\n```\n\n##### 升级依赖\n根据package.json文件重新安装到当前配置的最新版本\n```code\n$ yarn upgrade\n->$ rm -rf node_modules && npm install\n```\n\n更多与NPM的CLI对比：[cli-commands-comparison](https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison)\n更多CLI介绍：[cli-introduction](https://yarnpkg.com/en/docs/cli/)\n\n### 其他\n提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。\n\n### 总结\n好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。\n\n","source":"_posts/Yarn-模块管理工具.md","raw":"title: Yarn-模块管理工具\ndate: 2017-01-11 19:39:50\nbanner: https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg\ntags: \n- Yarn\n- NPM\n- 工具\n- 陈小饼\ncategories:\n- yarn\n- npm\n- 工具\n---\n\n### 简介\n2016年10月11日，facebook发布新的模块管理工具Yarn。   \n随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n-   安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n-   允许安装packages时执行代码，埋下安全隐患。\n-   安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。\n<!-- more -->\n\n### Yarn vs NPM\n#### yarn.lock\nNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：\n\n-   指定版本号（1.2.2）：只安装指定版本\n-   波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）\n-   插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）\n\n当执行`npm install [package] --save`时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。\n\nyarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的`npm-shrinkwrap.json`，需要通过执行 `npm shrinkwrap` 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。\n\n#### 更快的模块下载\nyarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。\n\n以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）\n\n除此，yarn还支持离线下载，前提是之前下过这个包。\n\n对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：\n```code\n$ yarn config set registry 'https://registry.npm.taobao.org'\n```\n\n#### 更简洁的输出\nyarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。\n\n更多信息：[migrating-from-npm](https://yarnpkg.com/en/docs/migrating-from-npm)\n\n\n### 使用\n#### 安装\n```code\n// 用Homebrew安装\n$ brew update\n$ brew install yarn\n\n// 用NPM安装\n$ npm install yarn -g\n```\n\n#### CLI\n##### 安装依赖\n安装package.json的依赖\n```code\n$ yarn\nor\n$ yarn install\n```\n\n本地安装某个模块依赖\n```code\n$ yarn add [package] \n->$ npm install [package] --save\n\n$ yarn add [package] [--dev/-D]\n->$ npm install --save-dev [package]\n```\n\n全局安装\n```code\n$ yarn global add [package]\n->$ npm install [--global/-g] [package]\n```\n\n##### 删除依赖\n```code\n$ yarn remove [package]\n->$ npm uninstall --save [package]\n```\n\n##### 升级依赖\n根据package.json文件重新安装到当前配置的最新版本\n```code\n$ yarn upgrade\n->$ rm -rf node_modules && npm install\n```\n\n更多与NPM的CLI对比：[cli-commands-comparison](https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison)\n更多CLI介绍：[cli-introduction](https://yarnpkg.com/en/docs/cli/)\n\n### 其他\n提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。\n\n### 总结\n好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。\n\n","slug":"Yarn-模块管理工具","published":1,"updated":"2017-01-24T07:41:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizy2vgkr0005a985n7vcvhw4","content":"<h3 id=\"u7B80_u4ECB\"><a href=\"#u7B80_u4ECB\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>2016年10月11日，facebook发布新的模块管理工具Yarn。<br>随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：</p>\n<ul>\n<li>安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。</li>\n<li>允许安装packages时执行代码，埋下安全隐患。</li>\n<li>安装packages的版本不够稳定等。</li>\n</ul>\n<p>为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。<br><a id=\"more\"></a></p>\n<h3 id=\"Yarn_vs_NPM\"><a href=\"#Yarn_vs_NPM\" class=\"headerlink\" title=\"Yarn vs NPM\"></a>Yarn vs NPM</h3><h4 id=\"yarn-lock\"><a href=\"#yarn-lock\" class=\"headerlink\" title=\"yarn.lock\"></a>yarn.lock</h4><p>NPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：</p>\n<ul>\n<li>指定版本号（1.2.2）：只安装指定版本</li>\n<li>波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）</li>\n<li>插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）</li>\n</ul>\n<p>当执行<code>npm install [package] --save</code>时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。</p>\n<p>yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的<code>npm-shrinkwrap.json</code>，需要通过执行 <code>npm shrinkwrap</code> 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。</p>\n<h4 id=\"u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\"><a href=\"#u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\" class=\"headerlink\" title=\"更快的模块下载\"></a>更快的模块下载</h4><p>yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。</p>\n<p>以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）</p>\n<p>除此，yarn还支持离线下载，前提是之前下过这个包。</p>\n<p>对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn config set registry &apos;https://registry.npm.taobao.org&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"u66F4_u7B80_u6D01_u7684_u8F93_u51FA\"><a href=\"#u66F4_u7B80_u6D01_u7684_u8F93_u51FA\" class=\"headerlink\" title=\"更简洁的输出\"></a>更简洁的输出</h4><p>yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。</p>\n<p>更多信息：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm\" target=\"_blank\" rel=\"external\">migrating-from-npm</a></p>\n<h3 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"u5B89_u88C5\"><a href=\"#u5B89_u88C5\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 用Homebrew安装</div><div class=\"line\">$ brew update</div><div class=\"line\">$ brew install yarn</div><div class=\"line\"></div><div class=\"line\">// 用NPM安装</div><div class=\"line\">$ npm install yarn -g</div></pre></td></tr></table></figure>\n<h4 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h4><h5 id=\"u5B89_u88C5_u4F9D_u8D56\"><a href=\"#u5B89_u88C5_u4F9D_u8D56\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><p>安装package.json的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn</div><div class=\"line\">or</div><div class=\"line\">$ yarn install</div></pre></td></tr></table></figure></p>\n<p>本地安装某个模块依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn add [package] </div><div class=\"line\">-&gt;$ npm install [package] --save</div><div class=\"line\"></div><div class=\"line\">$ yarn add [package] [--dev/-D]</div><div class=\"line\">-&gt;$ npm install --save-dev [package]</div></pre></td></tr></table></figure></p>\n<p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn global add [package]</div><div class=\"line\">-&gt;$ npm install [--global/-g] [package]</div></pre></td></tr></table></figure></p>\n<h5 id=\"u5220_u9664_u4F9D_u8D56\"><a href=\"#u5220_u9664_u4F9D_u8D56\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn remove [package]</div><div class=\"line\">-&gt;$ npm uninstall --save [package]</div></pre></td></tr></table></figure>\n<h5 id=\"u5347_u7EA7_u4F9D_u8D56\"><a href=\"#u5347_u7EA7_u4F9D_u8D56\" class=\"headerlink\" title=\"升级依赖\"></a>升级依赖</h5><p>根据package.json文件重新安装到当前配置的最新版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn upgrade</div><div class=\"line\">-&gt;$ rm -rf node_modules &amp;&amp; npm install</div></pre></td></tr></table></figure></p>\n<p>更多与NPM的CLI对比：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison\" target=\"_blank\" rel=\"external\">cli-commands-comparison</a><br>更多CLI介绍：<a href=\"https://yarnpkg.com/en/docs/cli/\" target=\"_blank\" rel=\"external\">cli-introduction</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。</p>\n","excerpt":"<h3 id=\"u7B80_u4ECB\"><a href=\"#u7B80_u4ECB\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>2016年10月11日，facebook发布新的模块管理工具Yarn。<br>随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：</p>\n<ul>\n<li>安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。</li>\n<li>允许安装packages时执行代码，埋下安全隐患。</li>\n<li>安装packages的版本不够稳定等。</li>\n</ul>\n<p>为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。<br>","more":"</p>\n<h3 id=\"Yarn_vs_NPM\"><a href=\"#Yarn_vs_NPM\" class=\"headerlink\" title=\"Yarn vs NPM\"></a>Yarn vs NPM</h3><h4 id=\"yarn-lock\"><a href=\"#yarn-lock\" class=\"headerlink\" title=\"yarn.lock\"></a>yarn.lock</h4><p>NPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：</p>\n<ul>\n<li>指定版本号（1.2.2）：只安装指定版本</li>\n<li>波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）</li>\n<li>插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）</li>\n</ul>\n<p>当执行<code>npm install [package] --save</code>时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。</p>\n<p>yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的<code>npm-shrinkwrap.json</code>，需要通过执行 <code>npm shrinkwrap</code> 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。</p>\n<h4 id=\"u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\"><a href=\"#u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\" class=\"headerlink\" title=\"更快的模块下载\"></a>更快的模块下载</h4><p>yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。</p>\n<p>以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）</p>\n<p>除此，yarn还支持离线下载，前提是之前下过这个包。</p>\n<p>对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn config set registry &apos;https://registry.npm.taobao.org&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"u66F4_u7B80_u6D01_u7684_u8F93_u51FA\"><a href=\"#u66F4_u7B80_u6D01_u7684_u8F93_u51FA\" class=\"headerlink\" title=\"更简洁的输出\"></a>更简洁的输出</h4><p>yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。</p>\n<p>更多信息：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm\">migrating-from-npm</a></p>\n<h3 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"u5B89_u88C5\"><a href=\"#u5B89_u88C5\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 用Homebrew安装</div><div class=\"line\">$ brew update</div><div class=\"line\">$ brew install yarn</div><div class=\"line\"></div><div class=\"line\">// 用NPM安装</div><div class=\"line\">$ npm install yarn -g</div></pre></td></tr></table></figure>\n<h4 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h4><h5 id=\"u5B89_u88C5_u4F9D_u8D56\"><a href=\"#u5B89_u88C5_u4F9D_u8D56\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><p>安装package.json的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn</div><div class=\"line\">or</div><div class=\"line\">$ yarn install</div></pre></td></tr></table></figure></p>\n<p>本地安装某个模块依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn add [package] </div><div class=\"line\">-&gt;$ npm install [package] --save</div><div class=\"line\"></div><div class=\"line\">$ yarn add [package] [--dev/-D]</div><div class=\"line\">-&gt;$ npm install --save-dev [package]</div></pre></td></tr></table></figure></p>\n<p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn global add [package]</div><div class=\"line\">-&gt;$ npm install [--global/-g] [package]</div></pre></td></tr></table></figure></p>\n<h5 id=\"u5220_u9664_u4F9D_u8D56\"><a href=\"#u5220_u9664_u4F9D_u8D56\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn remove [package]</div><div class=\"line\">-&gt;$ npm uninstall --save [package]</div></pre></td></tr></table></figure>\n<h5 id=\"u5347_u7EA7_u4F9D_u8D56\"><a href=\"#u5347_u7EA7_u4F9D_u8D56\" class=\"headerlink\" title=\"升级依赖\"></a>升级依赖</h5><p>根据package.json文件重新安装到当前配置的最新版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn upgrade</div><div class=\"line\">-&gt;$ rm -rf node_modules &amp;&amp; npm install</div></pre></td></tr></table></figure></p>\n<p>更多与NPM的CLI对比：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison\">cli-commands-comparison</a><br>更多CLI介绍：<a href=\"https://yarnpkg.com/en/docs/cli/\">cli-introduction</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。</p>"},{"title":"React Lifecycle","date":"2016-12-29T07:25:08.000Z","_content":"## 生命周期\n\nMore Info: [Component Specs and Lifecycle](http://reactjs.cn/react/docs/component-specs.html)\n\n## 组件渲染经历的生命周期\n\n### 第一次渲染：\n- getDefaultProps\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### 第二次渲染：\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### Props改变时：\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### State改变时：\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### 组件卸载时：\n- componentWillUnmont","source":"_posts/react-lifecycle.md","raw":"---\ntitle: React Lifecycle\ndate: 2016-12-29 15:25:08\ntags:\n- react\ncategories:\n- react\n---\n## 生命周期\n\nMore Info: [Component Specs and Lifecycle](http://reactjs.cn/react/docs/component-specs.html)\n\n## 组件渲染经历的生命周期\n\n### 第一次渲染：\n- getDefaultProps\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### 第二次渲染：\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### Props改变时：\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### State改变时：\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### 组件卸载时：\n- componentWillUnmont","slug":"react-lifecycle","published":1,"updated":"2017-01-24T07:41:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizy2vgkv0006a985u78lsmoc","content":"<h2 id=\"u751F_u547D_u5468_u671F\"><a href=\"#u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>More Info: <a href=\"http://reactjs.cn/react/docs/component-specs.html\" target=\"_blank\" rel=\"external\">Component Specs and Lifecycle</a></p>\n<h2 id=\"u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\"><a href=\"#u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"组件渲染经历的生命周期\"></a>组件渲染经历的生命周期</h2><h3 id=\"u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第一次渲染：\"></a>第一次渲染：</h3><ul>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第二次渲染：\"></a>第二次渲染：</h3><ul>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"Props_u6539_u53D8_u65F6_uFF1A\"><a href=\"#Props_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"Props改变时：\"></a>Props改变时：</h3><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"State_u6539_u53D8_u65F6_uFF1A\"><a href=\"#State_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"State改变时：\"></a>State改变时：</h3><ul>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\"><a href=\"#u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\" class=\"headerlink\" title=\"组件卸载时：\"></a>组件卸载时：</h3><ul>\n<li>componentWillUnmont</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"u751F_u547D_u5468_u671F\"><a href=\"#u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>More Info: <a href=\"http://reactjs.cn/react/docs/component-specs.html\">Component Specs and Lifecycle</a></p>\n<h2 id=\"u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\"><a href=\"#u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"组件渲染经历的生命周期\"></a>组件渲染经历的生命周期</h2><h3 id=\"u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第一次渲染：\"></a>第一次渲染：</h3><ul>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第二次渲染：\"></a>第二次渲染：</h3><ul>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"Props_u6539_u53D8_u65F6_uFF1A\"><a href=\"#Props_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"Props改变时：\"></a>Props改变时：</h3><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"State_u6539_u53D8_u65F6_uFF1A\"><a href=\"#State_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"State改变时：\"></a>State改变时：</h3><ul>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\"><a href=\"#u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\" class=\"headerlink\" title=\"组件卸载时：\"></a>组件卸载时：</h3><ul>\n<li>componentWillUnmont</li>\n</ul>\n"},{"title":"XMLHttpRequest","date":"2016-12-30T02:28:11.000Z","_content":"### Ajax & XMLHttpRequest\n\najax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。\n\n![what_is_ajax](https://alisonchenab.github.io/images/what_is_ajax.png)\n\n### XMLHttpRequest发展历程\n\n#### level1缺点：\n\n1. 只支持文本数据的传送，无法用来读取和上传二进制文件。\n2. 传送和接收数据时，没有进度信息，只能提示有没有完成。\n3. 受到\"同域限制\"，只能向同一域名的服务器请求数据。\n\n#### level2改进点：\n\n1. 可以设置HTTP请求的时限。\n2. 可以使用FormData对象管理表单数据。\n3. 可以上传文件。\n4. 可以请求不同域名下的数据（跨域请求）。\n5. 可以获取服务器端的二进制数据。\n6. 可以获得数据传输的进度信息。\n\n### XMLHttpRequest使用\n\n```code\n\nfunction sendAjax(data) {\n    // 创建xhr对象\n    var xhr = new XMLHttpRequest();\n    // 设置xhr请求的超时时间\n    xhr.timeout = 3000;\n    // 设置响应返回的超时时间\n    xhr.responseType = 'text';\n    // 创建一个post请求,采用异步\n    xhr.open('POST', '/server', true);\n    // 注册相关事件回调处理函数\n    xhr.onload = function(e){\n        if(this.status == 200 || this.status == 304){\n            alert(this.responseText);\n        }\n    };\n    xhr.ontimeout = function(e) {}\n    xhr.onerror = function(e) {}\n    xhr.upload.onprogress = function(e) {}\n\n    // 发送数据\n    xhr.send(data);\n}\n\n```\n\n\n","source":"_posts/XMLHttpRequest.md","raw":"---\ntitle: XMLHttpRequest\ndate: 2016-12-30 10:28:11\ntags:\n- http\ncategories:\n- http\n---\n### Ajax & XMLHttpRequest\n\najax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。\n\n![what_is_ajax](https://alisonchenab.github.io/images/what_is_ajax.png)\n\n### XMLHttpRequest发展历程\n\n#### level1缺点：\n\n1. 只支持文本数据的传送，无法用来读取和上传二进制文件。\n2. 传送和接收数据时，没有进度信息，只能提示有没有完成。\n3. 受到\"同域限制\"，只能向同一域名的服务器请求数据。\n\n#### level2改进点：\n\n1. 可以设置HTTP请求的时限。\n2. 可以使用FormData对象管理表单数据。\n3. 可以上传文件。\n4. 可以请求不同域名下的数据（跨域请求）。\n5. 可以获取服务器端的二进制数据。\n6. 可以获得数据传输的进度信息。\n\n### XMLHttpRequest使用\n\n```code\n\nfunction sendAjax(data) {\n    // 创建xhr对象\n    var xhr = new XMLHttpRequest();\n    // 设置xhr请求的超时时间\n    xhr.timeout = 3000;\n    // 设置响应返回的超时时间\n    xhr.responseType = 'text';\n    // 创建一个post请求,采用异步\n    xhr.open('POST', '/server', true);\n    // 注册相关事件回调处理函数\n    xhr.onload = function(e){\n        if(this.status == 200 || this.status == 304){\n            alert(this.responseText);\n        }\n    };\n    xhr.ontimeout = function(e) {}\n    xhr.onerror = function(e) {}\n    xhr.upload.onprogress = function(e) {}\n\n    // 发送数据\n    xhr.send(data);\n}\n\n```\n\n\n","slug":"XMLHttpRequest","published":1,"updated":"2017-01-24T07:41:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizy2vgkx0007a985986ldxp3","content":"<h3 id=\"Ajax__26amp_3B_XMLHttpRequest\"><a href=\"#Ajax__26amp_3B_XMLHttpRequest\" class=\"headerlink\" title=\"Ajax &amp; XMLHttpRequest\"></a>Ajax &amp; XMLHttpRequest</h3><p>ajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。</p>\n<p><img src=\"https://alisonchenab.github.io/images/what_is_ajax.png\" alt=\"what_is_ajax\"></p>\n<h3 id=\"XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\"><a href=\"#XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\" class=\"headerlink\" title=\"XMLHttpRequest发展历程\"></a>XMLHttpRequest发展历程</h3><h4 id=\"level1_u7F3A_u70B9_uFF1A\"><a href=\"#level1_u7F3A_u70B9_uFF1A\" class=\"headerlink\" title=\"level1缺点：\"></a>level1缺点：</h4><ol>\n<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>\n<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>\n<li>受到”同域限制”，只能向同一域名的服务器请求数据。</li>\n</ol>\n<h4 id=\"level2_u6539_u8FDB_u70B9_uFF1A\"><a href=\"#level2_u6539_u8FDB_u70B9_uFF1A\" class=\"headerlink\" title=\"level2改进点：\"></a>level2改进点：</h4><ol>\n<li>可以设置HTTP请求的时限。</li>\n<li>可以使用FormData对象管理表单数据。</li>\n<li>可以上传文件。</li>\n<li>可以请求不同域名下的数据（跨域请求）。</li>\n<li>可以获取服务器端的二进制数据。</li>\n<li>可以获得数据传输的进度信息。</li>\n</ol>\n<h3 id=\"XMLHttpRequest_u4F7F_u7528\"><a href=\"#XMLHttpRequest_u4F7F_u7528\" class=\"headerlink\" title=\"XMLHttpRequest使用\"></a>XMLHttpRequest使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function sendAjax(data) &#123;</div><div class=\"line\">    // 创建xhr对象</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    // 设置xhr请求的超时时间</div><div class=\"line\">    xhr.timeout = 3000;</div><div class=\"line\">    // 设置响应返回的超时时间</div><div class=\"line\">    xhr.responseType = &apos;text&apos;;</div><div class=\"line\">    // 创建一个post请求,采用异步</div><div class=\"line\">    xhr.open(&apos;POST&apos;, &apos;/server&apos;, true);</div><div class=\"line\">    // 注册相关事件回调处理函数</div><div class=\"line\">    xhr.onload = function(e)&#123;</div><div class=\"line\">        if(this.status == 200 || this.status == 304)&#123;</div><div class=\"line\">            alert(this.responseText);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    xhr.ontimeout = function(e) &#123;&#125;</div><div class=\"line\">    xhr.onerror = function(e) &#123;&#125;</div><div class=\"line\">    xhr.upload.onprogress = function(e) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    // 发送数据</div><div class=\"line\">    xhr.send(data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"Ajax__26amp_3B_XMLHttpRequest\"><a href=\"#Ajax__26amp_3B_XMLHttpRequest\" class=\"headerlink\" title=\"Ajax &amp; XMLHttpRequest\"></a>Ajax &amp; XMLHttpRequest</h3><p>ajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。</p>\n<p><img src=\"https://alisonchenab.github.io/images/what_is_ajax.png\" alt=\"what_is_ajax\"></p>\n<h3 id=\"XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\"><a href=\"#XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\" class=\"headerlink\" title=\"XMLHttpRequest发展历程\"></a>XMLHttpRequest发展历程</h3><h4 id=\"level1_u7F3A_u70B9_uFF1A\"><a href=\"#level1_u7F3A_u70B9_uFF1A\" class=\"headerlink\" title=\"level1缺点：\"></a>level1缺点：</h4><ol>\n<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>\n<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>\n<li>受到”同域限制”，只能向同一域名的服务器请求数据。</li>\n</ol>\n<h4 id=\"level2_u6539_u8FDB_u70B9_uFF1A\"><a href=\"#level2_u6539_u8FDB_u70B9_uFF1A\" class=\"headerlink\" title=\"level2改进点：\"></a>level2改进点：</h4><ol>\n<li>可以设置HTTP请求的时限。</li>\n<li>可以使用FormData对象管理表单数据。</li>\n<li>可以上传文件。</li>\n<li>可以请求不同域名下的数据（跨域请求）。</li>\n<li>可以获取服务器端的二进制数据。</li>\n<li>可以获得数据传输的进度信息。</li>\n</ol>\n<h3 id=\"XMLHttpRequest_u4F7F_u7528\"><a href=\"#XMLHttpRequest_u4F7F_u7528\" class=\"headerlink\" title=\"XMLHttpRequest使用\"></a>XMLHttpRequest使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function sendAjax(data) &#123;</div><div class=\"line\">    // 创建xhr对象</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    // 设置xhr请求的超时时间</div><div class=\"line\">    xhr.timeout = 3000;</div><div class=\"line\">    // 设置响应返回的超时时间</div><div class=\"line\">    xhr.responseType = &apos;text&apos;;</div><div class=\"line\">    // 创建一个post请求,采用异步</div><div class=\"line\">    xhr.open(&apos;POST&apos;, &apos;/server&apos;, true);</div><div class=\"line\">    // 注册相关事件回调处理函数</div><div class=\"line\">    xhr.onload = function(e)&#123;</div><div class=\"line\">        if(this.status == 200 || this.status == 304)&#123;</div><div class=\"line\">            alert(this.responseText);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    xhr.ontimeout = function(e) &#123;&#125;</div><div class=\"line\">    xhr.onerror = function(e) &#123;&#125;</div><div class=\"line\">    xhr.upload.onprogress = function(e) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    // 发送数据</div><div class=\"line\">    xhr.send(data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cizy2vgkv0006a985u78lsmoc","category_id":"cizy2vgky0008a985w727sw0x","_id":"cizy2vgl4000ja985axyflvj1"},{"post_id":"cizy2vgkd0000a98594voypnj","category_id":"cizy2vgko0003a985i8j3yzw6","_id":"cizy2vgl5000ma985crk10n8t"},{"post_id":"cizy2vgkd0000a98594voypnj","category_id":"cizy2vgl3000ga9857h6cdigh","_id":"cizy2vgl6000pa985kcduq9m4"},{"post_id":"cizy2vgkx0007a985986ldxp3","category_id":"cizy2vgl4000ka98576q3ci4e","_id":"cizy2vgl6000ra985gdvy5i9e"},{"post_id":"cizy2vgkl0002a985g31fnull","category_id":"cizy2vgky0008a985w727sw0x","_id":"cizy2vgl7000wa985qpr7gwxb"},{"post_id":"cizy2vgkl0002a985g31fnull","category_id":"cizy2vgl5000na9850t2bd60p","_id":"cizy2vgl7000ya985nf0xzbok"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","category_id":"cizy2vgkz000aa985t36rwxhp","_id":"cizy2vgl90012a985kzdecgh9"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","category_id":"cizy2vgl6000ta985t2b83ky2","_id":"cizy2vgl90014a9855yng7u2c"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","category_id":"cizy2vgl7000za985ump7f9kl","_id":"cizy2vgl90017a985rykz209y"}],"PostTag":[{"post_id":"cizy2vgkd0000a98594voypnj","tag_id":"cizy2vgkq0004a9858tckve2j","_id":"cizy2vgl3000ea985q9g7vhnn"},{"post_id":"cizy2vgkd0000a98594voypnj","tag_id":"cizy2vgky0009a985i53noz0t","_id":"cizy2vgl3000fa985zzpascim"},{"post_id":"cizy2vgkd0000a98594voypnj","tag_id":"cizy2vgl0000ba985riu9vpvg","_id":"cizy2vgl4000ia98541a7t6bv"},{"post_id":"cizy2vgkl0002a985g31fnull","tag_id":"cizy2vgl1000da9857z53ewxw","_id":"cizy2vgl6000qa985fbdmfc95"},{"post_id":"cizy2vgkl0002a985g31fnull","tag_id":"cizy2vgl3000ha985jpyuep2i","_id":"cizy2vgl6000sa985gv8om0po"},{"post_id":"cizy2vgkl0002a985g31fnull","tag_id":"cizy2vgl0000ba985riu9vpvg","_id":"cizy2vgl7000va985cpwgnadl"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","tag_id":"cizy2vgl5000oa985gasarsq9","_id":"cizy2vgl90013a985z38yii8o"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","tag_id":"cizy2vgl7000ua985fgh1c9wr","_id":"cizy2vgl90015a9854axh94j0"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","tag_id":"cizy2vgl7000xa985ju0shqr7","_id":"cizy2vgl90018a985f5uikhl8"},{"post_id":"cizy2vgkr0005a985n7vcvhw4","tag_id":"cizy2vgl0000ba985riu9vpvg","_id":"cizy2vgl90019a985zfhlpw3p"},{"post_id":"cizy2vgkv0006a985u78lsmoc","tag_id":"cizy2vgl1000da9857z53ewxw","_id":"cizy2vgl9001aa9852rqobo96"},{"post_id":"cizy2vgkx0007a985986ldxp3","tag_id":"cizy2vgl90016a985zx4rizrs","_id":"cizy2vgl9001ba985fip25hbf"}],"Tag":[{"name":"promise","_id":"cizy2vgkq0004a9858tckve2j"},{"name":"异步编程","_id":"cizy2vgky0009a985i53noz0t"},{"name":"陈小饼","_id":"cizy2vgl0000ba985riu9vpvg"},{"name":"react","_id":"cizy2vgl1000da9857z53ewxw"},{"name":"test","_id":"cizy2vgl3000ha985jpyuep2i"},{"name":"Yarn","_id":"cizy2vgl5000oa985gasarsq9"},{"name":"NPM","_id":"cizy2vgl7000ua985fgh1c9wr"},{"name":"工具","_id":"cizy2vgl7000xa985ju0shqr7"},{"name":"http","_id":"cizy2vgl90016a985zx4rizrs"}]}}