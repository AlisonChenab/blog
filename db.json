{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/what_is_ajax.png","path":"images/what_is_ajax.png","modified":1,"renderable":0},{"_id":"themes/tkl/source/css/all.styl","path":"css/all.styl","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/animate.css","path":"css/animate.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/animsition.min.css","path":"css/animsition.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/iconList.css","path":"css/iconList.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/flexslider.css","path":"css/flexslider.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/ie8.css","path":"css/ie8.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/slidebars.min.css","path":"css/slidebars.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/screen.css","path":"css/screen.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.eot","path":"fonts/icons.eot","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.woff","path":"fonts/icons.woff","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/arta.css","path":"highlightjs/arta.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/ascetic.css","path":"highlightjs/ascetic.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/brown_paper.css","path":"highlightjs/brown_paper.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/default.css","path":"highlightjs/default.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/dark.css","path":"highlightjs/dark.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/brown_papersq.png","path":"highlightjs/brown_papersq.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/foundation.css","path":"highlightjs/foundation.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/github.css","path":"highlightjs/github.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/far.css","path":"highlightjs/far.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/googlecode.css","path":"highlightjs/googlecode.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/idea.css","path":"highlightjs/idea.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/ir_black.css","path":"highlightjs/ir_black.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/magula.css","path":"highlightjs/magula.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/mono-blue.css","path":"highlightjs/mono-blue.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/monokai.css","path":"highlightjs/monokai.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/docco.css","path":"highlightjs/docco.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/monokai_sublime.css","path":"highlightjs/monokai_sublime.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/obsidian.css","path":"highlightjs/obsidian.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/pojoaque.css","path":"highlightjs/pojoaque.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/pojoaque.jpg","path":"highlightjs/pojoaque.jpg","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/railscasts.css","path":"highlightjs/railscasts.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/rainbow.css","path":"highlightjs/rainbow.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/school_book.png","path":"highlightjs/school_book.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/school_book.css","path":"highlightjs/school_book.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/solarized_dark.css","path":"highlightjs/solarized_dark.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/solarized_light.css","path":"highlightjs/solarized_light.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/sunburst.css","path":"highlightjs/sunburst.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-blue.css","path":"highlightjs/tomorrow-night-blue.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-bright.css","path":"highlightjs/tomorrow-night-bright.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-eighties.css","path":"highlightjs/tomorrow-night-eighties.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow-night.css","path":"highlightjs/tomorrow-night.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/tomorrow.css","path":"highlightjs/tomorrow.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/xcode.css","path":"highlightjs/xcode.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/vs.css","path":"highlightjs/vs.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/highlightjs/zenburn.css","path":"highlightjs/zenburn.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/close.png","path":"img/close.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/favicon副本.ico","path":"img/favicon副本.ico","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/html5shiv.min.js","path":"js/html5shiv.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery.ajaxchimp.min.js","path":"js/jquery.ajaxchimp.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery.flexslider-min.js","path":"js/jquery.flexslider-min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/scripts.js","path":"js/scripts.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/respond.min.js","path":"js/respond.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/tkl/source/fonts/icons.svg","path":"fonts/icons.svg","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/jquery-1.11.1.min.js","path":"js/jquery-1.11.1.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/bg_img.jpg","path":"img/bg_img.jpg","modified":1,"renderable":1},{"_id":"themes/tkl/source/js/plugins.min.js","path":"js/plugins.min.js","modified":1,"renderable":1},{"_id":"themes/tkl/source/img/bg_img_bear.jpg","path":"img/bg_img_bear.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3f3b738aec4ec3051ad6ca338b1373c06cdbe4cc","modified":1491824758000},{"_id":"themes/tkl/.DS_Store","hash":"60cfccc499e63088aa7ddd4b3fe2ae0267c62496","modified":1494295304000},{"_id":"themes/tkl/README.md","hash":"f5e4750b3da64867597b466d861688a6dbcb3f02","modified":1485142319000},{"_id":"themes/tkl/LICENSE","hash":"c700a8b9312d24bdc57570f7d6a131cf63d89016","modified":1485141475000},{"_id":"themes/tkl/.git","hash":"015b90824e4e713871fad3fef5f37f4198e555fa","modified":1485141475000},{"_id":"themes/tkl/_config.yml","hash":"bc1d6ddc095eb2c84b5c092cddcd3a9589e40d54","modified":1485229217000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1486269052000},{"_id":"source/_posts/Promise-JavaScript异步编程.md","hash":"9515aeedf82890cf74d02301d7d7dfc4f74edf24","modified":1488803004000},{"_id":"source/_posts/Hybrid框架.md","hash":"b649a237d0485cf18d90c69820b3469b1ba7169a","modified":1491794058000},{"_id":"source/_posts/React组件单元测试.md","hash":"99baf496235c0a5a8fa6b430ef60d34a25daf0ce","modified":1485243669000},{"_id":"source/_posts/XMLHttpRequest.md","hash":"830d31270f16c7194c609f7565f760b63ce8ab64","modified":1485243680000},{"_id":"source/_posts/Yarn-模块管理工具.md","hash":"bd1445c0bcdbda26babfcced41b36b4604745cd5","modified":1485243719000},{"_id":"source/_posts/react-lifecycle.md","hash":"047e3c5d82469b7423e550ed7945aaa22e6f9b6b","modified":1485243697000},{"_id":"source/about/index.md","hash":"cdfe52b7b413cb75385b3440f23cfca0bcedb6fb","modified":1485227486000},{"_id":"source/_posts/webpack性能优化.md","hash":"ab3ec29e4d619eb225d836015ba4ee503f3bb095","modified":1491311509000},{"_id":"source/images/what_is_ajax.png","hash":"5f0f3f2122152e38e08fa58d05e0a021be17e36b","modified":1485141447000},{"_id":"themes/tkl/layout/.DS_Store","hash":"b7cc2922b5fc2e142b770f6e4a46b630a84ca185","modified":1494295299000},{"_id":"themes/tkl/layout/about.ejs","hash":"9a6da09178130877fa7c6852fe41c714b46b773c","modified":1485228316000},{"_id":"themes/tkl/layout/archive.ejs","hash":"43e2dd0a6f82acba7e8dae563ff358854e63338d","modified":1485141475000},{"_id":"themes/tkl/layout/index.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1485141475000},{"_id":"themes/tkl/layout/layout.ejs","hash":"943af95c1710ceb334b2e57248e78bd93e3832b8","modified":1485245263000},{"_id":"themes/tkl/layout/category.ejs","hash":"7b863018dd9b05f8a1ebabf58e96add0049d7abe","modified":1485141475000},{"_id":"themes/tkl/layout/page.ejs","hash":"f2c2725c591d5b24da9cf632fd6c3587867cc2c0","modified":1485141475000},{"_id":"themes/tkl/layout/post.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1485141475000},{"_id":"themes/tkl/layout/tag.ejs","hash":"3e22a8a5281d7648d90b604f95cbdd1790008a70","modified":1485141475000},{"_id":"themes/tkl/source/.DS_Store","hash":"84f35e390633eadc3c78584a28f5f5f8ce7f43a5","modified":1494295310000},{"_id":"themes/tkl/layout/_widget/archive.ejs","hash":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/category.ejs","hash":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/recent_posts.ejs","hash":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/tag.ejs","hash":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1485141475000},{"_id":"themes/tkl/layout/_widget/tagcloud.ejs","hash":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1485141475000},{"_id":"themes/tkl/layout/casper/.DS_Store","hash":"0af4458db0eb004a5a78c033931219532df46e65","modified":1494295299000},{"_id":"themes/tkl/layout/casper/about.ejs","hash":"7108cb498135e862b5b30077a370a53b6571e00e","modified":1485331759000},{"_id":"themes/tkl/layout/casper/after_all.ejs","hash":"bf795bd5c6b645fcf14292d602dabd9e6d49cae3","modified":1485141475000},{"_id":"themes/tkl/layout/casper/archive.ejs","hash":"e89d44b7c0104b47d93418c27f4b2d8c0da2ba28","modified":1485331756000},{"_id":"themes/tkl/layout/casper/footer.ejs","hash":"1559fa25d44c661fbd50f8ba6c0b96c663988c7f","modified":1485160401000},{"_id":"themes/tkl/layout/casper/head.ejs","hash":"32596dce306a2e528b2681ddc1c15bb768b2cf44","modified":1485141475000},{"_id":"themes/tkl/layout/casper/header.ejs","hash":"89782c924beb7fa7ef32f85733832823c524a711","modified":1485244526000},{"_id":"themes/tkl/layout/casper/index.ejs","hash":"0dedd857571b1521197be334e5df712d4e08b10f","modified":1485332884000},{"_id":"themes/tkl/layout/casper/post.ejs","hash":"f0e9270e45bfc8cf8b533a71f09ce1cd2cd5c543","modified":1485141475000},{"_id":"themes/tkl/source/css/all.styl","hash":"b281ab5f908e16005c9e4e57f51ac7da9c4aab29","modified":1485141475000},{"_id":"themes/tkl/source/css/animate.css","hash":"fca75b84887199a0ed8e0f056ff30f5a1302f324","modified":1485141475000},{"_id":"themes/tkl/source/css/animsition.min.css","hash":"59033074f6594a0d87c759e2b8cf9baa3a62ed6a","modified":1485141475000},{"_id":"themes/tkl/source/css/custom.css","hash":"02e701a0dddde40f940df04f48aa3b0e27fd9f5b","modified":1485141475000},{"_id":"themes/tkl/source/css/iconList.css","hash":"f78ffffb4be40a6b0eb6ee109c958ccd062d1ae5","modified":1485141475000},{"_id":"themes/tkl/source/css/flexslider.css","hash":"faebc8c54ca41e3c9936edaffbabbebd512c6d5a","modified":1485141475000},{"_id":"themes/tkl/source/css/ie8.css","hash":"cfdfe07ecc9f3afa5bab47155b49f0924f62d2c2","modified":1485141475000},{"_id":"themes/tkl/source/css/slidebars.min.css","hash":"a802c15d9bf06005b463901be8325d8ce38b5b04","modified":1485141475000},{"_id":"themes/tkl/source/css/screen.css","hash":"a13c2c6fe420f76083df2da6d7b2d765dd8b467e","modified":1485141475000},{"_id":"themes/tkl/source/css/syntax.styl","hash":"f39ea1e483c9244f39003d3efd20deb535ecddc7","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1485141475000},{"_id":"themes/tkl/source/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/arta.css","hash":"08766ac9d70bde457fea9c553140029f57ace65a","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/ascetic.css","hash":"dd5e0c6c11bc199884cc5abf7310e79ce8018d0d","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/brown_paper.css","hash":"2a987d30dd142a5c316ace70e919e3312707ebbd","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/default.css","hash":"108ad8410aa3004eafc452ae60771a2ae24d7988","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/dark.css","hash":"38045930b1d862bb6e14960e94e63782145a598f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/brown_papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/foundation.css","hash":"308c2e0458fc117b323f7d9ce1644f7b4e52d99e","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/github.css","hash":"53f47e65e6e0e6068baf5c4b638b04d2f4e0b0bc","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/far.css","hash":"8178ac70abe577ae8345f1f6291bf7d489ad384d","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/googlecode.css","hash":"731e74bcdfd1b68aae5b5805540f727c31309ba2","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/idea.css","hash":"fb77c293850c454c1f0c72628c0b301537765ad2","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/ir_black.css","hash":"2da52e8562b412039b5816e1a3a2f59e7dff0c27","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/magula.css","hash":"5666f49986f05fb8956e0c3065a383b252779442","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/mono-blue.css","hash":"c143e9d8c62dc71ca39bc0b6c127464ed2396e4f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/monokai.css","hash":"a0edb8327c191516a04d456db8aae9044055a5cf","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/docco.css","hash":"70199b44d688d0a22851bd5481260f24160a38ee","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/monokai_sublime.css","hash":"6b4716416b1bba643d3a7926221ce6d83a139141","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/obsidian.css","hash":"d6c264e1973beb9f20001b9a4013e9983923b34e","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/pojoaque.css","hash":"c9b048dc71c5b45d5cb3daac8f332a7e5d13b20f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/railscasts.css","hash":"aeb6ecd79552b9611d447fe56de5266954ea055c","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/rainbow.css","hash":"b0e18f0f7fa08d5ad11956e2d9cc5e2ffdd514f3","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/school_book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/school_book.css","hash":"f257d41cdca2609fa4c664df9cc14b48e2bcb09f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/solarized_dark.css","hash":"007f9f1e7addf7e2040734cd1f733d041432c335","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/solarized_light.css","hash":"a85878fd70ecd03c71944df1acbbf320bac7979f","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/sunburst.css","hash":"e72bc116795505c1fcae35bc69045043fc34a243","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-blue.css","hash":"e2bed22abcdf3f2b8ca3a1a73624751d3edc4e64","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-bright.css","hash":"afdb004743a8d2b52d38c7a1fce32d631a0f3ded","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night-eighties.css","hash":"9603bc778de2dabd0ce1e7ee272a047338a8b99c","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow-night.css","hash":"48cd18ce93daa491d89eb63e5fe3ab640ff56d74","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/tomorrow.css","hash":"a184e23b28b6a6401ecfc35e0a94de0bada589e4","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/xcode.css","hash":"78cb5758ce4085aa51edb6c5beb64d8f4511edd7","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/vs.css","hash":"13e2f7ec2e197d79f4fc36768ea4a0663d41e1c0","modified":1485141475000},{"_id":"themes/tkl/source/highlightjs/zenburn.css","hash":"73dafd21563f5fc3bb74856d4abf97c447a27772","modified":1485141475000},{"_id":"themes/tkl/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1494295496000},{"_id":"themes/tkl/source/img/close.png","hash":"e52e6a61877efd98ddad9ca31ece27e8ee977327","modified":1485141475000},{"_id":"themes/tkl/source/img/favicon.ico","hash":"3949b76770d3cffcdc4298bfe7eaab4a2ea83531","modified":1494295341000},{"_id":"themes/tkl/source/img/favicon副本.ico","hash":"5557409832d7bb97e0e236acb758aabdfa0065c9","modified":1485141475000},{"_id":"themes/tkl/source/img/logo.png","hash":"3949b76770d3cffcdc4298bfe7eaab4a2ea83531","modified":1494295341000},{"_id":"themes/tkl/source/js/html5shiv.min.js","hash":"bb51a5f6c394989bb06e4171179354c6d05ec8f8","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery.ajaxchimp.min.js","hash":"9be17785b0d816e1cd6bc45908e1805e0522fe18","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery.flexslider-min.js","hash":"51b3a7d882f438d53dc69ca5289e92254160c09a","modified":1485141475000},{"_id":"themes/tkl/source/js/scripts.js","hash":"4e4ebd697d00d3d0fcea7cbf78f5a7312e2f22ed","modified":1485141475000},{"_id":"themes/tkl/source/js/respond.min.js","hash":"b5aba40d65b0d6f85859db47f757ea971a0efd30","modified":1485141475000},{"_id":"themes/tkl/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1485141475000},{"_id":"themes/tkl/source/css/style.css","hash":"3e26ab1f78440b22938b4d012b43b6d6859c35b3","modified":1485333131000},{"_id":"themes/tkl/source/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1485141475000},{"_id":"themes/tkl/source/js/jquery-1.11.1.min.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/duoshuo.ejs","hash":"2e043e5950bafefc08616a31ce37762ccf838cfb","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/meta.ejs","hash":"c984cdc774bc884b33c8d87e3b59728cfdee773c","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/comments.ejs","hash":"8246718d5a5838d6093971d52b8b217da3f4ea8c","modified":1485141475000},{"_id":"themes/tkl/layout/casper/post/navigation.ejs","hash":"2cdf5a26df9e43d0df1a08aad1cb934e7aea3b4a","modified":1485141475000},{"_id":"themes/tkl/source/img/bg_img.jpg","hash":"36263c65562c7ff11bc2b973e235ebce57a7773c","modified":1485162027000},{"_id":"themes/tkl/source/js/plugins.min.js","hash":"5d2edd4ecc4b27af81a3255ca8a253d23fc518e1","modified":1485141475000},{"_id":"themes/tkl/source/img/bg_img_bear.jpg","hash":"3dd99bb3c09798ce11837521222944570756437c","modified":1485141475000}],"Category":[{"name":"promise","_id":"cj2gwzzzl00030o85r9o3ys08"},{"name":"react","_id":"cj2gx000600080o85r2t6i8cc"},{"name":"http","_id":"cj2gx000j000c0o85bmex9n9l"},{"name":"异步编程","parent":"cj2gwzzzl00030o85r9o3ys08","_id":"cj2gx000k000f0o85eqrrrzi2"},{"name":"yarn","_id":"cj2gx000l000k0o852vy6sy42"},{"name":"test","parent":"cj2gx000600080o85r2t6i8cc","_id":"cj2gx000n000p0o85pb4zcbll"},{"name":"npm","parent":"cj2gx000l000k0o852vy6sy42","_id":"cj2gx000o000u0o851olhyki1"},{"name":"工具","parent":"cj2gx000o000u0o851olhyki1","_id":"cj2gx000p000y0o85y3phm35y"}],"Data":[],"Page":[{"title":"about","date":"2017-01-24T03:11:26.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-24 11:11:26\n---\n","updated":"2017-01-24T03:11:26.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj2gwzzzf00010o85w0vxo61p","content":"","excerpt":"","more":""}],"Post":[{"title":"Promise-JavaScript异步编程","date":"2017-03-05T06:57:24.000Z","banner":"https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg","_content":"\nPromise是异步编程的一种解决方案。\n\n### Why Promise?\nJavascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。\n\nES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。\n\n基本用法如下：\n```code\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n关于链式写法，借用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的图参考如下：\n![Promise Chain](https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png)\n\nPromise有三种状态，分别是`pending`表示初始状态；`fulfilled`(或`resolved`)表示操作成功完成；`rejected`表示操作失败。状态的改变只有2种可能，从`pending`变成`fulfilled`以及从`pending`变成`rejected`，一旦状态改变，就不会再变。\n\n<!-- more -->\n\n以Ajax为例：\n```code\nvar ajax = function(url){\n  return new Promise(function(resolve, reject){\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url, true);\n    xhr.responseType = \"json\";\n    xhr.onreadystatechange = readyStateHandle;\n    xhr.send();\n\n    function readyStateHandle(){\n      if(this.readyState !== 4) return;\n      if(this.status === 200){\n        resolve(this.response);\n      }else{\n        reject(new Error(this.statusText));\n      }\n    }\n  });\n}\n```\n\n目前Chrome、Firefox、Safari的高版本已经支持Promise。\n\n### Promise API\n#### .then()\n为Promise实例添加状态改变时的回调函数。第一个参数是`fulfilled`状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是`rejected`状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。\n\n继续上面的Ajax的例子，用法如下：\n```code\najax(\"./posts.json\").then((json) => {\n  console.log('Contents:', json);\n}, (error) => {\n  console.error('出错了', error);\n});\n```\n\n`then`方法返回的是一个新的Promise实例，因此可以使用链式写法。\n\n第一个`fulfilled`回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个`then`方法的`fulfilled`回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个string\n  return json.nextJsonUrl;\n}).then(\n  url => console.log(url),  // 得到json.nextJsonUrl对应的值，一个string\n  error => console.error('出错了', error)\n)\n```\n\n第二种是返回一个Promise对象，则第二个`then`将会等待当前状态发生变化之后再按照结果决定调用哪个回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个Promise对象\n  return ajax(json.nextJsonUrl);\n}).then(\n  nextJson => console.log(nextJson),  // 假设成功，得到第二个json的内容\n  error => console.error('出错了', error)\n)\n```\n\n#### .catch()\n`catch`方法用于指定发生错误时的回调函数，等同于`then(null, rejection)`，如下：\n```code\najax(\"./posts.json\").then(\n  json => {...}, \n  error => console.error('出错了', error)\n)\n// 等同于\najax(\"./posts.json\").then(\n  json => {...}\n).catch(\n  error => console.error('出错了', error)\n)\n```\n用`catch`能够捕获ajax()抛出的错误和`then`方法执行过程中发生的异常或错误，相对`then`用`catch`处理`rejected`状态的写法更佳。\n\n`catch`方法返回的还是一个Promise对象，因此接下去还可以继续使用`then`方法。\n```code\najax(\"./posts.json\").then(json => {\n  return ajax(json.nextJsonUrl);\n}).catch(\n  error => console.error('出错了', error)\n).then(\n  nextJson => console.log(nextJson)\n)\n```\n如果`catch`之前没有报错，则直接跳过`catch`执行下一个`then`方法，这时候这个`then`是否报错与前面的`catch`就无关了。若当前`catch`方法中抛出错误，在当前`catch`中是无法捕获的，需要在后面的`catch`方法中捕获/处理。\n\n#### .all() & .race()\n`all`方法和`race`方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过`Promise.resolve`方法转化，返回的每个成员都是Promise实例。\n\n对于`all`方法，只有所有成员都变成`fulfilled`，`promises`的状态才会变成`fulfilled`，这时的返回值组成一个数组传递给`promises`的回调函数；只要任何一个成员的状态变为`rejected`，`promises`的状态就会变成`rejected`，第一个被`rejected`的实例的返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.all([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组\n}).catch((error)=>{\n  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息\n});\n```\n\n对于`race`方法，只要其中一个成员率先改变状态，就会作为返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.race([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值\n}).catch((error)=>{\n  console.error(error); \n  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误\n});\n```\n\n#### .resolve()\n`resolve`方法用于将传入的参数转化为Promise对象。\n```code\nPromise.resolve(\"Hello World\");\n// 等同于\nnew Promise(resolve => {\n  resolve(\"Hello World\");\n})\n```\n\n传参可能有四种情况：\n- 参数是一个Promise实例：不做任何改变返回。\n- 参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。\n- 参数根本不是对象：返回一个状态为Resolved的Promise对象。\n- 不带任何参数：直接返回一个Resolved状态的Promise对象。\n\n#### .reject()\n`reject`方法会返回一个为`rejected`状态的Promise对象。\n```code\nPromise.reject(\"error!\");\n// 类似于\nnew Promise((resolve, reject) => {\n  reject(\"error!\");\n}).catch(\n  error => console.error(error) // 控制台的输出稍有不同\n)\n```\n\n`reject`方法的参数会原封不动的作为错误的返回值，如：\n```code\nPromise.reject(ajax(\"./posts.json\"));\n```\n即使已经成功获取到`posts.json`的内容，控制台仍然会输出`Uncaught (in promise) ...`。\n\n### 总结\n对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。\n\n\n参考：[ECMAScript 6入门－Promise对象](http://es6.ruanyifeng.com/#docs/promise)","source":"_posts/Promise-JavaScript异步编程.md","raw":"title: Promise-JavaScript异步编程\ndate: 2017-03-05 14:57:24\nbanner: https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/promise/banner_promise.jpg\ntags:\n- promise\n- 异步编程\n- 陈小饼\ncategories:\n- promise\n- 异步编程\n---\n\nPromise是异步编程的一种解决方案。\n\n### Why Promise?\nJavascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。\n\nES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。\n\n基本用法如下：\n```code\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n关于链式写法，借用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的图参考如下：\n![Promise Chain](https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png)\n\nPromise有三种状态，分别是`pending`表示初始状态；`fulfilled`(或`resolved`)表示操作成功完成；`rejected`表示操作失败。状态的改变只有2种可能，从`pending`变成`fulfilled`以及从`pending`变成`rejected`，一旦状态改变，就不会再变。\n\n<!-- more -->\n\n以Ajax为例：\n```code\nvar ajax = function(url){\n  return new Promise(function(resolve, reject){\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url, true);\n    xhr.responseType = \"json\";\n    xhr.onreadystatechange = readyStateHandle;\n    xhr.send();\n\n    function readyStateHandle(){\n      if(this.readyState !== 4) return;\n      if(this.status === 200){\n        resolve(this.response);\n      }else{\n        reject(new Error(this.statusText));\n      }\n    }\n  });\n}\n```\n\n目前Chrome、Firefox、Safari的高版本已经支持Promise。\n\n### Promise API\n#### .then()\n为Promise实例添加状态改变时的回调函数。第一个参数是`fulfilled`状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是`rejected`状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。\n\n继续上面的Ajax的例子，用法如下：\n```code\najax(\"./posts.json\").then((json) => {\n  console.log('Contents:', json);\n}, (error) => {\n  console.error('出错了', error);\n});\n```\n\n`then`方法返回的是一个新的Promise实例，因此可以使用链式写法。\n\n第一个`fulfilled`回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个`then`方法的`fulfilled`回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个string\n  return json.nextJsonUrl;\n}).then(\n  url => console.log(url),  // 得到json.nextJsonUrl对应的值，一个string\n  error => console.error('出错了', error)\n)\n```\n\n第二种是返回一个Promise对象，则第二个`then`将会等待当前状态发生变化之后再按照结果决定调用哪个回调：\n```code\najax(\"./posts.json\").then(json => {\n  // 返回一个Promise对象\n  return ajax(json.nextJsonUrl);\n}).then(\n  nextJson => console.log(nextJson),  // 假设成功，得到第二个json的内容\n  error => console.error('出错了', error)\n)\n```\n\n#### .catch()\n`catch`方法用于指定发生错误时的回调函数，等同于`then(null, rejection)`，如下：\n```code\najax(\"./posts.json\").then(\n  json => {...}, \n  error => console.error('出错了', error)\n)\n// 等同于\najax(\"./posts.json\").then(\n  json => {...}\n).catch(\n  error => console.error('出错了', error)\n)\n```\n用`catch`能够捕获ajax()抛出的错误和`then`方法执行过程中发生的异常或错误，相对`then`用`catch`处理`rejected`状态的写法更佳。\n\n`catch`方法返回的还是一个Promise对象，因此接下去还可以继续使用`then`方法。\n```code\najax(\"./posts.json\").then(json => {\n  return ajax(json.nextJsonUrl);\n}).catch(\n  error => console.error('出错了', error)\n).then(\n  nextJson => console.log(nextJson)\n)\n```\n如果`catch`之前没有报错，则直接跳过`catch`执行下一个`then`方法，这时候这个`then`是否报错与前面的`catch`就无关了。若当前`catch`方法中抛出错误，在当前`catch`中是无法捕获的，需要在后面的`catch`方法中捕获/处理。\n\n#### .all() & .race()\n`all`方法和`race`方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过`Promise.resolve`方法转化，返回的每个成员都是Promise实例。\n\n对于`all`方法，只有所有成员都变成`fulfilled`，`promises`的状态才会变成`fulfilled`，这时的返回值组成一个数组传递给`promises`的回调函数；只要任何一个成员的状态变为`rejected`，`promises`的状态就会变成`rejected`，第一个被`rejected`的实例的返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.all([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组\n}).catch((error)=>{\n  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息\n});\n```\n\n对于`race`方法，只要其中一个成员率先改变状态，就会作为返回值传递给`promises`的回调函数。\n```code\nvar promises = Promise.race([p1,p2,p3]).then((posts)=>{\n  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值\n}).catch((error)=>{\n  console.error(error); \n  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误\n});\n```\n\n#### .resolve()\n`resolve`方法用于将传入的参数转化为Promise对象。\n```code\nPromise.resolve(\"Hello World\");\n// 等同于\nnew Promise(resolve => {\n  resolve(\"Hello World\");\n})\n```\n\n传参可能有四种情况：\n- 参数是一个Promise实例：不做任何改变返回。\n- 参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。\n- 参数根本不是对象：返回一个状态为Resolved的Promise对象。\n- 不带任何参数：直接返回一个Resolved状态的Promise对象。\n\n#### .reject()\n`reject`方法会返回一个为`rejected`状态的Promise对象。\n```code\nPromise.reject(\"error!\");\n// 类似于\nnew Promise((resolve, reject) => {\n  reject(\"error!\");\n}).catch(\n  error => console.error(error) // 控制台的输出稍有不同\n)\n```\n\n`reject`方法的参数会原封不动的作为错误的返回值，如：\n```code\nPromise.reject(ajax(\"./posts.json\"));\n```\n即使已经成功获取到`posts.json`的内容，控制台仍然会输出`Uncaught (in promise) ...`。\n\n### 总结\n对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。\n\n\n参考：[ECMAScript 6入门－Promise对象](http://es6.ruanyifeng.com/#docs/promise)","slug":"Promise-JavaScript异步编程","published":1,"updated":"2017-03-06T12:23:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gwzzz900000o85tawegq90","content":"<p>Promise是异步编程的一种解决方案。</p>\n<h3 id=\"Why_Promise_3F\"><a href=\"#Why_Promise_3F\" class=\"headerlink\" title=\"Why Promise?\"></a>Why Promise?</h3><p>Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。</p>\n<p>ES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。</p>\n<p>基本用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>关于链式写法，借用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">MDN</a>的图参考如下：<br><img src=\"https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png\" alt=\"Promise Chain\"></p>\n<p>Promise有三种状态，分别是<code>pending</code>表示初始状态；<code>fulfilled</code>(或<code>resolved</code>)表示操作成功完成；<code>rejected</code>表示操作失败。状态的改变只有2种可能，从<code>pending</code>变成<code>fulfilled</code>以及从<code>pending</code>变成<code>rejected</code>，一旦状态改变，就不会再变。</p>\n<a id=\"more\"></a>\n<p>以Ajax为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ajax = function(url)&#123;</div><div class=\"line\">  return new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.responseType = &quot;json&quot;;</div><div class=\"line\">    xhr.onreadystatechange = readyStateHandle;</div><div class=\"line\">    xhr.send();</div><div class=\"line\"></div><div class=\"line\">    function readyStateHandle()&#123;</div><div class=\"line\">      if(this.readyState !== 4) return;</div><div class=\"line\">      if(this.status === 200)&#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>目前Chrome、Firefox、Safari的高版本已经支持Promise。</p>\n<h3 id=\"Promise_API\"><a href=\"#Promise_API\" class=\"headerlink\" title=\"Promise API\"></a>Promise API</h3><h4 id=\"then_28_29\"><a href=\"#then_28_29\" class=\"headerlink\" title=\".then()\"></a>.then()</h4><p>为Promise实例添加状态改变时的回调函数。第一个参数是<code>fulfilled</code>状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是<code>rejected</code>状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。</p>\n<p>继续上面的Ajax的例子，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then((json) =&gt; &#123;</div><div class=\"line\">  console.log(&apos;Contents:&apos;, json);</div><div class=\"line\">&#125;, (error) =&gt; &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法返回的是一个新的Promise实例，因此可以使用链式写法。</p>\n<p>第一个<code>fulfilled</code>回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个<code>then</code>方法的<code>fulfilled</code>回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个string</div><div class=\"line\">  return json.nextJsonUrl;</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  url =&gt; console.log(url),  // 得到json.nextJsonUrl对应的值，一个string</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>第二种是返回一个Promise对象，则第二个<code>then</code>将会等待当前状态发生变化之后再按照结果决定调用哪个回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个Promise对象</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson),  // 假设成功，得到第二个json的内容</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h4 id=\"catch_28_29\"><a href=\"#catch_28_29\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h4><p><code>catch</code>方法用于指定发生错误时的回调函数，等同于<code>then(null, rejection)</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;, </div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div><div class=\"line\">// 等同于</div><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>用<code>catch</code>能够捕获ajax()抛出的错误和<code>then</code>方法执行过程中发生的异常或错误，相对<code>then</code>用<code>catch</code>处理<code>rejected</code>状态的写法更佳。</p>\n<p><code>catch</code>方法返回的还是一个Promise对象，因此接下去还可以继续使用<code>then</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>如果<code>catch</code>之前没有报错，则直接跳过<code>catch</code>执行下一个<code>then</code>方法，这时候这个<code>then</code>是否报错与前面的<code>catch</code>就无关了。若当前<code>catch</code>方法中抛出错误，在当前<code>catch</code>中是无法捕获的，需要在后面的<code>catch</code>方法中捕获/处理。</p>\n<h4 id=\"all_28_29__26amp_3B_-race_28_29\"><a href=\"#all_28_29__26amp_3B_-race_28_29\" class=\"headerlink\" title=\".all() &amp; .race()\"></a>.all() &amp; .race()</h4><p><code>all</code>方法和<code>race</code>方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过<code>Promise.resolve</code>方法转化，返回的每个成员都是Promise实例。</p>\n<p>对于<code>all</code>方法，只有所有成员都变成<code>fulfilled</code>，<code>promises</code>的状态才会变成<code>fulfilled</code>，这时的返回值组成一个数组传递给<code>promises</code>的回调函数；只要任何一个成员的状态变为<code>rejected</code>，<code>promises</code>的状态就会变成<code>rejected</code>，第一个被<code>rejected</code>的实例的返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.all([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>race</code>方法，只要其中一个成员率先改变状态，就会作为返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.race([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); </div><div class=\"line\">  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"resolve_28_29\"><a href=\"#resolve_28_29\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h4><p><code>resolve</code>方法用于将传入的参数转化为Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.resolve(&quot;Hello World&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">new Promise(resolve =&gt; &#123;</div><div class=\"line\">  resolve(&quot;Hello World&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>传参可能有四种情况：</p>\n<ul>\n<li>参数是一个Promise实例：不做任何改变返回。</li>\n<li>参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。</li>\n<li>参数根本不是对象：返回一个状态为Resolved的Promise对象。</li>\n<li>不带任何参数：直接返回一个Resolved状态的Promise对象。</li>\n</ul>\n<h4 id=\"reject_28_29\"><a href=\"#reject_28_29\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h4><p><code>reject</code>方法会返回一个为<code>rejected</code>状态的Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(&quot;error!&quot;);</div><div class=\"line\">// 类似于</div><div class=\"line\">new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">  reject(&quot;error!&quot;);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(error) // 控制台的输出稍有不同</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p><code>reject</code>方法的参数会原封不动的作为错误的返回值，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(ajax(&quot;./posts.json&quot;));</div></pre></td></tr></table></figure></p>\n<p>即使已经成功获取到<code>posts.json</code>的内容，控制台仍然会输出<code>Uncaught (in promise) ...</code>。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。</p>\n<p>参考：<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">ECMAScript 6入门－Promise对象</a></p>\n","excerpt":"<p>Promise是异步编程的一种解决方案。</p>\n<h3 id=\"Why_Promise_3F\"><a href=\"#Why_Promise_3F\" class=\"headerlink\" title=\"Why Promise?\"></a>Why Promise?</h3><p>Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。</p>\n<p>ES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。</p>\n<p>基本用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>关于链式写法，借用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN</a>的图参考如下：<br><img src=\"https://future-team.github.io/blog-resources/imgs/promise/promise_chain.png\" alt=\"Promise Chain\"></p>\n<p>Promise有三种状态，分别是<code>pending</code>表示初始状态；<code>fulfilled</code>(或<code>resolved</code>)表示操作成功完成；<code>rejected</code>表示操作失败。状态的改变只有2种可能，从<code>pending</code>变成<code>fulfilled</code>以及从<code>pending</code>变成<code>rejected</code>，一旦状态改变，就不会再变。</p>","more":"<p>以Ajax为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ajax = function(url)&#123;</div><div class=\"line\">  return new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.responseType = &quot;json&quot;;</div><div class=\"line\">    xhr.onreadystatechange = readyStateHandle;</div><div class=\"line\">    xhr.send();</div><div class=\"line\"></div><div class=\"line\">    function readyStateHandle()&#123;</div><div class=\"line\">      if(this.readyState !== 4) return;</div><div class=\"line\">      if(this.status === 200)&#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>目前Chrome、Firefox、Safari的高版本已经支持Promise。</p>\n<h3 id=\"Promise_API\"><a href=\"#Promise_API\" class=\"headerlink\" title=\"Promise API\"></a>Promise API</h3><h4 id=\"then_28_29\"><a href=\"#then_28_29\" class=\"headerlink\" title=\".then()\"></a>.then()</h4><p>为Promise实例添加状态改变时的回调函数。第一个参数是<code>fulfilled</code>状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是<code>rejected</code>状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。</p>\n<p>继续上面的Ajax的例子，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then((json) =&gt; &#123;</div><div class=\"line\">  console.log(&apos;Contents:&apos;, json);</div><div class=\"line\">&#125;, (error) =&gt; &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法返回的是一个新的Promise实例，因此可以使用链式写法。</p>\n<p>第一个<code>fulfilled</code>回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个<code>then</code>方法的<code>fulfilled</code>回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个string</div><div class=\"line\">  return json.nextJsonUrl;</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  url =&gt; console.log(url),  // 得到json.nextJsonUrl对应的值，一个string</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>第二种是返回一个Promise对象，则第二个<code>then</code>将会等待当前状态发生变化之后再按照结果决定调用哪个回调：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  // 返回一个Promise对象</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson),  // 假设成功，得到第二个json的内容</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h4 id=\"catch_28_29\"><a href=\"#catch_28_29\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h4><p><code>catch</code>方法用于指定发生错误时的回调函数，等同于<code>then(null, rejection)</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;, </div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div><div class=\"line\">// 等同于</div><div class=\"line\">ajax(&quot;./posts.json&quot;).then(</div><div class=\"line\">  json =&gt; &#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>用<code>catch</code>能够捕获ajax()抛出的错误和<code>then</code>方法执行过程中发生的异常或错误，相对<code>then</code>用<code>catch</code>处理<code>rejected</code>状态的写法更佳。</p>\n<p><code>catch</code>方法返回的还是一个Promise对象，因此接下去还可以继续使用<code>then</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ajax(&quot;./posts.json&quot;).then(json =&gt; &#123;</div><div class=\"line\">  return ajax(json.nextJsonUrl);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(&apos;出错了&apos;, error)</div><div class=\"line\">).then(</div><div class=\"line\">  nextJson =&gt; console.log(nextJson)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>如果<code>catch</code>之前没有报错，则直接跳过<code>catch</code>执行下一个<code>then</code>方法，这时候这个<code>then</code>是否报错与前面的<code>catch</code>就无关了。若当前<code>catch</code>方法中抛出错误，在当前<code>catch</code>中是无法捕获的，需要在后面的<code>catch</code>方法中捕获/处理。</p>\n<h4 id=\"all_28_29__26amp_3B_-race_28_29\"><a href=\"#all_28_29__26amp_3B_-race_28_29\" class=\"headerlink\" title=\".all() &amp; .race()\"></a>.all() &amp; .race()</h4><p><code>all</code>方法和<code>race</code>方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过<code>Promise.resolve</code>方法转化，返回的每个成员都是Promise实例。</p>\n<p>对于<code>all</code>方法，只有所有成员都变成<code>fulfilled</code>，<code>promises</code>的状态才会变成<code>fulfilled</code>，这时的返回值组成一个数组传递给<code>promises</code>的回调函数；只要任何一个成员的状态变为<code>rejected</code>，<code>promises</code>的状态就会变成<code>rejected</code>，第一个被<code>rejected</code>的实例的返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.all([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>race</code>方法，只要其中一个成员率先改变状态，就会作为返回值传递给<code>promises</code>的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promises = Promise.race([p1,p2,p3]).then((posts)=&gt;&#123;</div><div class=\"line\">  console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值</div><div class=\"line\">&#125;).catch((error)=&gt;&#123;</div><div class=\"line\">  console.error(error); </div><div class=\"line\">  // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"resolve_28_29\"><a href=\"#resolve_28_29\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h4><p><code>resolve</code>方法用于将传入的参数转化为Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.resolve(&quot;Hello World&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">new Promise(resolve =&gt; &#123;</div><div class=\"line\">  resolve(&quot;Hello World&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>传参可能有四种情况：</p>\n<ul>\n<li>参数是一个Promise实例：不做任何改变返回。</li>\n<li>参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。</li>\n<li>参数根本不是对象：返回一个状态为Resolved的Promise对象。</li>\n<li>不带任何参数：直接返回一个Resolved状态的Promise对象。</li>\n</ul>\n<h4 id=\"reject_28_29\"><a href=\"#reject_28_29\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h4><p><code>reject</code>方法会返回一个为<code>rejected</code>状态的Promise对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(&quot;error!&quot;);</div><div class=\"line\">// 类似于</div><div class=\"line\">new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">  reject(&quot;error!&quot;);</div><div class=\"line\">&#125;).catch(</div><div class=\"line\">  error =&gt; console.error(error) // 控制台的输出稍有不同</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p><code>reject</code>方法的参数会原封不动的作为错误的返回值，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Promise.reject(ajax(&quot;./posts.json&quot;));</div></pre></td></tr></table></figure></p>\n<p>即使已经成功获取到<code>posts.json</code>的内容，控制台仍然会输出<code>Uncaught (in promise) ...</code>。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。</p>\n<p>参考：<a href=\"http://es6.ruanyifeng.com/#docs/promise\">ECMAScript 6入门－Promise对象</a></p>"},{"title":"Hybrid框架","date":"2017-04-05T02:34:12.000Z","banner":"https://future-team.github.io/blog-resources/imgs/hybrid-framework/banner_hybrid.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/hybrid-framework/banner_hybrid.jpg","_content":"\n### Cordova & PhoneGap 入门\n\n`Apacha Cordova`是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。\n`Apacha Cordova`是从`PhoneGap`中抽出的核心代码，是驱动`PhoneGap`的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。\n\n> You can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. \n\n推荐阅读：[PhoneGap, Cordova, and what’s in a name?](http://phonegap.com/blog/2012/03/19/phonegap-cordova-and-whate28099s-in-a-name/)\n\n<!-- more -->\n\n#### Cordova\n##### 使用\n- 全局安装cordova。\n```code\n$ sudo npm install -g cordova\n``` \n\n- 用cordova创建项目。\n```code\n$ cordova create hello com.example.hello HelloWorld\n```\n\n- 增加平台platforms。\n```code\n$ cordova platform add ios --save\n$ cordova platform add android --save\n\n// 查看平台\n$ cordova platform ls\n```\n\n- 安装构建项目的环境，查看环境要求，之后按照步骤搭建起来。\n```code\n$ cordova requirements\n\n>>\nRequirements check results for android:\nJava JDK: installed 1.8.0\nAndroid SDK: installed true\nAndroid target: installed android-25\nGradle: installed \n\nRequirements check results for ios:\nApple OS X: installed darwin\nXcode: installed 8.1\nios-deploy: installed 1.9.1\nCocoaPods: installed \n```\n\n- 构建项目。\n```code\n$ cordova build \n// 或单独某个平台如IOS\n$ cordova build ios\n```\n\n- 安装cordova插件。\n```code\n$ cordova plugin add cordova-plugin-camera\n// 查看项目插件\n$ cordova plugin ls\n```\n\n重要插件地址: [core-plugin-apis](https://cordova.apache.org/docs/en/6.x/guide/support/index.html#core-plugin-apis)\n更多其他插件: [plugreg](http://www.plugreg.com/)\n\n##### 创建插件\n插件必须配置`plugin.xml`文件，`id`表示插件名，`platform`对应当前配置的平台，`js-module`对应Javascript文件路径，`header-file`和`source-file`分别对应`.h`和`.m`文件。具体参数可以参考: [plugin.xml](https://cordova.apache.org/docs/en/6.x/plugin_ref/spec.html)\n```code\n$ cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git\n```\n\n可以通过`plugman`检验当前插件是否能正确安装到各个平台。\n```code\n$ npm install -g plugman\n$ plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin\n```\n\n如果要写一个兼容Android/IOS的插件，需要会不同平台的语言，还是有点挑战的。具体的开发方式可以参照官网。发布直接通过npm的方式`npm publish`的方式即可，记得在发布之前新建`package.json`文件记录插件的各类信息。\n\n#### PhoneGap\n`PhoneGap`提供了桌面应用和通过`phonegap cli`来创建/操作项目，同时提供了移动端的调试工具，通过wifi连接即可。\n\n##### 使用\n- 全局安装phonegap。\n```code\n$ npm install -g phonegap@latest\n```\n\n- 创建项目，通过客户端创建相对会慢很多，不指定模板默认`phonegap-template-hello-world`。\n```code\n$ phonegap create myApp\n\n>>\nCreating a new cordova project.\n\nUsing cordova-fetch for phonegap-template-hello-world\n```\n\n- 增加平台platforms和插件plugin的命令和cordova类似，直接用cordova命令也是可以的。但在phonegap项目中在执行添加平台的命令会添加很多的常用的插件，需要等待一段时间，但是很大程度省去了安装插件的操作。\n```code\n$ phonegap platform add ios\n\n$ phonegap plugin add cordova-plugin-device\n```\n\n- 将项目拖拽到phonegap客户端界面，可自定义服务的端口，然后手机端连接项目查看效果。或者通过cli开启服务，不需要安装平台(ios/android/.etc)的依赖就可以直接看到效果。\n```code\n$ phonegap serve\n\n// 默认端口3000，可通过以下命令改变端口并开启服务\nphonegap serve --port, -p <n> \n```\n\n- 调用插件，以拍照为例。\n```code\n// html\n<div id=\"camera\">拍照<div>\n\n// JavaScript\n// 插件调用都以 `navigator.插件名.方法`\nvar camera = document.getElementById('camera');\ncamaraButton.addEventListener('click', function(){\n    navigator.camera.getPicture(onLoadImageSuccess, onLoadImageFail);\n}, false);\n\nfunction onLoadImageSuccess(imageURI){ // 成功返回图片地址\n    alert(imageURI);\n}\n\nfunction onLoadImageFail(message){ // 失败返回错误原因\n    navigator.notification.alert(\"拍照失败，原因：\" + message, null, \"警告\");\n}\n\n```\n\n### 主流Hybrid框架对比\n### OnsenUI\n提供Angular 1, 2, React 和 Vue.js框架的移动端开发，还需要配合PhoneGap/Cordova实现跨平台开发。\n\n项目地址：[https://github.com/OnsenUI/OnsenUI](https://github.com/OnsenUI/OnsenUI)\n\n优势：\n- 文档完善，提供丰富的示例。\n- 提供较多的预定义组件，如Grid、Dialog、Form等常用组件。\n- 提供2套样式，支持Material Design。\n- 提供monaca脚手架，让项目搭建更方便。\n- 多框架语言的支持：React、Angular1/2、Vue2、Meteor。\n- 持续维护，更新及时。\n\n劣势：\n- 不包含但支持PhoneGap/Cordova构建。\n\n推荐指数：🌟🌟🌟🌟🌟\n\n#### Ionic\n使用Angular构建跨平台app。\n\n项目地址：[https://github.com/driftyco/ionic](https://github.com/driftyco/ionic)\n\n优势：\n- 提供Creator非代码环境拖拽组件构建App。\n- 提供丰富的预定义组件，如Grid、Modals、Input、Menus等组件。\n- 提供不同平台的样式选择和修改方式，支持Material Design。\n- 完善的文档，庞大的社区。\n\n劣势：\n- 必须会使用AngularJS去完成复杂的开发。\n\n推荐指数：🌟🌟🌟🌟🌟\n\n#### Framework 7\n全功能的HTML框架，用于构建iOS和Android应用程序。针对IOS的UI设计，如果要兼容Android需要另外使用PhoneGap/Cordova。\n\n项目地址：[https://github.com/nolimits4web/Framework7/](https://github.com/nolimits4web/Framework7/)\n\n优势：\n- 丰富的示例、教程，容易上手。\n- 丰富的组件和插件。\n- 能够轻易和js框架配合使用，如React、Vue。\n\n劣势：\n- 不包含但支持PhoneGap/Cordova构建。\n- 没有提供脚手架，只提供了最基础的服务。\n\n推荐指数：🌟🌟🌟🌟\n\n#### React Native\n用React构建跨原生app，和PhoneGap/Cordov原理不一样，性能表现更流畅。\n\n项目地址：[https://github.com/facebook/react-native](https://github.com/facebook/react-native)\n\n优势：\n- 仿原生的表现，相对流畅。\n- 庞大的社区。\n\n劣势：\n- 学习曲线陡，需要适当学习客户端开发。\n- 跨平台的兼容性有待考究。\n\n推荐指数：🌟🌟🌟\n\n### 总结\n稍微普及了PhoneGap/Cordova，是目前比较成熟和稳定的实现用JavaScript开发的Hybrid框架，但是由于还是通过WebView去展现，所以在性能方面还是不如原生Native来的流畅。\n\n对比当中混入了React Native，其实现原理和PhoneGap/Cordova没什么太大关系。目前很多人用React Native开发项目，从入门到放弃，目前还有太多兼容性和需要自定义的部分，开发成本比预期要来的高，要求开发者不仅会Web的技术，还需要IOS／Android的技术。\n\n\n\n\n\n\n\n","source":"_posts/Hybrid框架.md","raw":"title: Hybrid框架\ndate: 2017-04-05 10:34:12\nbanner: https://future-team.github.io/blog-resources/imgs/hybrid-framework/banner_hybrid.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/hybrid-framework/banner_hybrid.jpg\ntags:\n- hybrid\n- 陈小饼\n---\n\n### Cordova & PhoneGap 入门\n\n`Apacha Cordova`是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。\n`Apacha Cordova`是从`PhoneGap`中抽出的核心代码，是驱动`PhoneGap`的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。\n\n> You can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. \n\n推荐阅读：[PhoneGap, Cordova, and what’s in a name?](http://phonegap.com/blog/2012/03/19/phonegap-cordova-and-whate28099s-in-a-name/)\n\n<!-- more -->\n\n#### Cordova\n##### 使用\n- 全局安装cordova。\n```code\n$ sudo npm install -g cordova\n``` \n\n- 用cordova创建项目。\n```code\n$ cordova create hello com.example.hello HelloWorld\n```\n\n- 增加平台platforms。\n```code\n$ cordova platform add ios --save\n$ cordova platform add android --save\n\n// 查看平台\n$ cordova platform ls\n```\n\n- 安装构建项目的环境，查看环境要求，之后按照步骤搭建起来。\n```code\n$ cordova requirements\n\n>>\nRequirements check results for android:\nJava JDK: installed 1.8.0\nAndroid SDK: installed true\nAndroid target: installed android-25\nGradle: installed \n\nRequirements check results for ios:\nApple OS X: installed darwin\nXcode: installed 8.1\nios-deploy: installed 1.9.1\nCocoaPods: installed \n```\n\n- 构建项目。\n```code\n$ cordova build \n// 或单独某个平台如IOS\n$ cordova build ios\n```\n\n- 安装cordova插件。\n```code\n$ cordova plugin add cordova-plugin-camera\n// 查看项目插件\n$ cordova plugin ls\n```\n\n重要插件地址: [core-plugin-apis](https://cordova.apache.org/docs/en/6.x/guide/support/index.html#core-plugin-apis)\n更多其他插件: [plugreg](http://www.plugreg.com/)\n\n##### 创建插件\n插件必须配置`plugin.xml`文件，`id`表示插件名，`platform`对应当前配置的平台，`js-module`对应Javascript文件路径，`header-file`和`source-file`分别对应`.h`和`.m`文件。具体参数可以参考: [plugin.xml](https://cordova.apache.org/docs/en/6.x/plugin_ref/spec.html)\n```code\n$ cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git\n```\n\n可以通过`plugman`检验当前插件是否能正确安装到各个平台。\n```code\n$ npm install -g plugman\n$ plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin\n```\n\n如果要写一个兼容Android/IOS的插件，需要会不同平台的语言，还是有点挑战的。具体的开发方式可以参照官网。发布直接通过npm的方式`npm publish`的方式即可，记得在发布之前新建`package.json`文件记录插件的各类信息。\n\n#### PhoneGap\n`PhoneGap`提供了桌面应用和通过`phonegap cli`来创建/操作项目，同时提供了移动端的调试工具，通过wifi连接即可。\n\n##### 使用\n- 全局安装phonegap。\n```code\n$ npm install -g phonegap@latest\n```\n\n- 创建项目，通过客户端创建相对会慢很多，不指定模板默认`phonegap-template-hello-world`。\n```code\n$ phonegap create myApp\n\n>>\nCreating a new cordova project.\n\nUsing cordova-fetch for phonegap-template-hello-world\n```\n\n- 增加平台platforms和插件plugin的命令和cordova类似，直接用cordova命令也是可以的。但在phonegap项目中在执行添加平台的命令会添加很多的常用的插件，需要等待一段时间，但是很大程度省去了安装插件的操作。\n```code\n$ phonegap platform add ios\n\n$ phonegap plugin add cordova-plugin-device\n```\n\n- 将项目拖拽到phonegap客户端界面，可自定义服务的端口，然后手机端连接项目查看效果。或者通过cli开启服务，不需要安装平台(ios/android/.etc)的依赖就可以直接看到效果。\n```code\n$ phonegap serve\n\n// 默认端口3000，可通过以下命令改变端口并开启服务\nphonegap serve --port, -p <n> \n```\n\n- 调用插件，以拍照为例。\n```code\n// html\n<div id=\"camera\">拍照<div>\n\n// JavaScript\n// 插件调用都以 `navigator.插件名.方法`\nvar camera = document.getElementById('camera');\ncamaraButton.addEventListener('click', function(){\n    navigator.camera.getPicture(onLoadImageSuccess, onLoadImageFail);\n}, false);\n\nfunction onLoadImageSuccess(imageURI){ // 成功返回图片地址\n    alert(imageURI);\n}\n\nfunction onLoadImageFail(message){ // 失败返回错误原因\n    navigator.notification.alert(\"拍照失败，原因：\" + message, null, \"警告\");\n}\n\n```\n\n### 主流Hybrid框架对比\n### OnsenUI\n提供Angular 1, 2, React 和 Vue.js框架的移动端开发，还需要配合PhoneGap/Cordova实现跨平台开发。\n\n项目地址：[https://github.com/OnsenUI/OnsenUI](https://github.com/OnsenUI/OnsenUI)\n\n优势：\n- 文档完善，提供丰富的示例。\n- 提供较多的预定义组件，如Grid、Dialog、Form等常用组件。\n- 提供2套样式，支持Material Design。\n- 提供monaca脚手架，让项目搭建更方便。\n- 多框架语言的支持：React、Angular1/2、Vue2、Meteor。\n- 持续维护，更新及时。\n\n劣势：\n- 不包含但支持PhoneGap/Cordova构建。\n\n推荐指数：🌟🌟🌟🌟🌟\n\n#### Ionic\n使用Angular构建跨平台app。\n\n项目地址：[https://github.com/driftyco/ionic](https://github.com/driftyco/ionic)\n\n优势：\n- 提供Creator非代码环境拖拽组件构建App。\n- 提供丰富的预定义组件，如Grid、Modals、Input、Menus等组件。\n- 提供不同平台的样式选择和修改方式，支持Material Design。\n- 完善的文档，庞大的社区。\n\n劣势：\n- 必须会使用AngularJS去完成复杂的开发。\n\n推荐指数：🌟🌟🌟🌟🌟\n\n#### Framework 7\n全功能的HTML框架，用于构建iOS和Android应用程序。针对IOS的UI设计，如果要兼容Android需要另外使用PhoneGap/Cordova。\n\n项目地址：[https://github.com/nolimits4web/Framework7/](https://github.com/nolimits4web/Framework7/)\n\n优势：\n- 丰富的示例、教程，容易上手。\n- 丰富的组件和插件。\n- 能够轻易和js框架配合使用，如React、Vue。\n\n劣势：\n- 不包含但支持PhoneGap/Cordova构建。\n- 没有提供脚手架，只提供了最基础的服务。\n\n推荐指数：🌟🌟🌟🌟\n\n#### React Native\n用React构建跨原生app，和PhoneGap/Cordov原理不一样，性能表现更流畅。\n\n项目地址：[https://github.com/facebook/react-native](https://github.com/facebook/react-native)\n\n优势：\n- 仿原生的表现，相对流畅。\n- 庞大的社区。\n\n劣势：\n- 学习曲线陡，需要适当学习客户端开发。\n- 跨平台的兼容性有待考究。\n\n推荐指数：🌟🌟🌟\n\n### 总结\n稍微普及了PhoneGap/Cordova，是目前比较成熟和稳定的实现用JavaScript开发的Hybrid框架，但是由于还是通过WebView去展现，所以在性能方面还是不如原生Native来的流畅。\n\n对比当中混入了React Native，其实现原理和PhoneGap/Cordova没什么太大关系。目前很多人用React Native开发项目，从入门到放弃，目前还有太多兼容性和需要自定义的部分，开发成本比预期要来的高，要求开发者不仅会Web的技术，还需要IOS／Android的技术。\n\n\n\n\n\n\n\n","slug":"Hybrid框架","published":1,"updated":"2017-04-10T03:14:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gwzzzi00020o85jxr8xv85","content":"<h3 id=\"Cordova__26amp_3B_PhoneGap__u5165_u95E8\"><a href=\"#Cordova__26amp_3B_PhoneGap__u5165_u95E8\" class=\"headerlink\" title=\"Cordova &amp; PhoneGap 入门\"></a>Cordova &amp; PhoneGap 入门</h3><p><code>Apacha Cordova</code>是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。<br><code>Apacha Cordova</code>是从<code>PhoneGap</code>中抽出的核心代码，是驱动<code>PhoneGap</code>的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。</p>\n<blockquote>\n<p>You can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. </p>\n</blockquote>\n<p>推荐阅读：<a href=\"http://phonegap.com/blog/2012/03/19/phonegap-cordova-and-whate28099s-in-a-name/\" target=\"_blank\" rel=\"external\">PhoneGap, Cordova, and what’s in a name?</a></p>\n<a id=\"more\"></a>\n<h4 id=\"Cordova\"><a href=\"#Cordova\" class=\"headerlink\" title=\"Cordova\"></a>Cordova</h4><h5 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li><p>全局安装cordova。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g cordova</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">- 用cordova创建项目。</div><div class=\"line\">```code</div><div class=\"line\">$ cordova create hello com.example.hello HelloWorld</div></pre></td></tr></table></figure>\n</li>\n<li><p>增加平台platforms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova platform add ios --save</div><div class=\"line\">$ cordova platform add android --save</div><div class=\"line\"></div><div class=\"line\">// 查看平台</div><div class=\"line\">$ cordova platform ls</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装构建项目的环境，查看环境要求，之后按照步骤搭建起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova requirements</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;</div><div class=\"line\">Requirements check results for android:</div><div class=\"line\">Java JDK: installed 1.8.0</div><div class=\"line\">Android SDK: installed true</div><div class=\"line\">Android target: installed android-25</div><div class=\"line\">Gradle: installed </div><div class=\"line\"></div><div class=\"line\">Requirements check results for ios:</div><div class=\"line\">Apple OS X: installed darwin</div><div class=\"line\">Xcode: installed 8.1</div><div class=\"line\">ios-deploy: installed 1.9.1</div><div class=\"line\">CocoaPods: installed</div></pre></td></tr></table></figure>\n</li>\n<li><p>构建项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova build </div><div class=\"line\">// 或单独某个平台如IOS</div><div class=\"line\">$ cordova build ios</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装cordova插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova plugin add cordova-plugin-camera</div><div class=\"line\">// 查看项目插件</div><div class=\"line\">$ cordova plugin ls</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>重要插件地址: <a href=\"https://cordova.apache.org/docs/en/6.x/guide/support/index.html#core-plugin-apis\" target=\"_blank\" rel=\"external\">core-plugin-apis</a><br>更多其他插件: <a href=\"http://www.plugreg.com/\" target=\"_blank\" rel=\"external\">plugreg</a></p>\n<h5 id=\"u521B_u5EFA_u63D2_u4EF6\"><a href=\"#u521B_u5EFA_u63D2_u4EF6\" class=\"headerlink\" title=\"创建插件\"></a>创建插件</h5><p>插件必须配置<code>plugin.xml</code>文件，<code>id</code>表示插件名，<code>platform</code>对应当前配置的平台，<code>js-module</code>对应Javascript文件路径，<code>header-file</code>和<code>source-file</code>分别对应<code>.h</code>和<code>.m</code>文件。具体参数可以参考: <a href=\"https://cordova.apache.org/docs/en/6.x/plugin_ref/spec.html\" target=\"_blank\" rel=\"external\">plugin.xml</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>plugman</code>检验当前插件是否能正确安装到各个平台。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g plugman</div><div class=\"line\">$ plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin</div></pre></td></tr></table></figure></p>\n<p>如果要写一个兼容Android/IOS的插件，需要会不同平台的语言，还是有点挑战的。具体的开发方式可以参照官网。发布直接通过npm的方式<code>npm publish</code>的方式即可，记得在发布之前新建<code>package.json</code>文件记录插件的各类信息。</p>\n<h4 id=\"PhoneGap\"><a href=\"#PhoneGap\" class=\"headerlink\" title=\"PhoneGap\"></a>PhoneGap</h4><p><code>PhoneGap</code>提供了桌面应用和通过<code>phonegap cli</code>来创建/操作项目，同时提供了移动端的调试工具，通过wifi连接即可。</p>\n<h5 id=\"u4F7F_u7528-1\"><a href=\"#u4F7F_u7528-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li><p>全局安装phonegap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g phonegap@latest</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建项目，通过客户端创建相对会慢很多，不指定模板默认<code>phonegap-template-hello-world</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap create myApp</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;</div><div class=\"line\">Creating a new cordova project.</div><div class=\"line\"></div><div class=\"line\">Using cordova-fetch for phonegap-template-hello-world</div></pre></td></tr></table></figure>\n</li>\n<li><p>增加平台platforms和插件plugin的命令和cordova类似，直接用cordova命令也是可以的。但在phonegap项目中在执行添加平台的命令会添加很多的常用的插件，需要等待一段时间，但是很大程度省去了安装插件的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap platform add ios</div><div class=\"line\"></div><div class=\"line\">$ phonegap plugin add cordova-plugin-device</div></pre></td></tr></table></figure>\n</li>\n<li><p>将项目拖拽到phonegap客户端界面，可自定义服务的端口，然后手机端连接项目查看效果。或者通过cli开启服务，不需要安装平台(ios/android/.etc)的依赖就可以直接看到效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap serve</div><div class=\"line\"></div><div class=\"line\">// 默认端口3000，可通过以下命令改变端口并开启服务</div><div class=\"line\">phonegap serve --port, -p &lt;n&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用插件，以拍照为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// html</div><div class=\"line\">&lt;div id=&quot;camera&quot;&gt;拍照&lt;div&gt;</div><div class=\"line\"></div><div class=\"line\">// JavaScript</div><div class=\"line\">// 插件调用都以 `navigator.插件名.方法`</div><div class=\"line\">var camera = document.getElementById(&apos;camera&apos;);</div><div class=\"line\">camaraButton.addEventListener(&apos;click&apos;, function()&#123;</div><div class=\"line\">    navigator.camera.getPicture(onLoadImageSuccess, onLoadImageFail);</div><div class=\"line\">&#125;, false);</div><div class=\"line\"></div><div class=\"line\">function onLoadImageSuccess(imageURI)&#123; // 成功返回图片地址</div><div class=\"line\">    alert(imageURI);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function onLoadImageFail(message)&#123; // 失败返回错误原因</div><div class=\"line\">    navigator.notification.alert(&quot;拍照失败，原因：&quot; + message, null, &quot;警告&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"u4E3B_u6D41Hybrid_u6846_u67B6_u5BF9_u6BD4\"><a href=\"#u4E3B_u6D41Hybrid_u6846_u67B6_u5BF9_u6BD4\" class=\"headerlink\" title=\"主流Hybrid框架对比\"></a>主流Hybrid框架对比</h3><h3 id=\"OnsenUI\"><a href=\"#OnsenUI\" class=\"headerlink\" title=\"OnsenUI\"></a>OnsenUI</h3><p>提供Angular 1, 2, React 和 Vue.js框架的移动端开发，还需要配合PhoneGap/Cordova实现跨平台开发。</p>\n<p>项目地址：<a href=\"https://github.com/OnsenUI/OnsenUI\" target=\"_blank\" rel=\"external\">https://github.com/OnsenUI/OnsenUI</a></p>\n<p>优势：</p>\n<ul>\n<li>文档完善，提供丰富的示例。</li>\n<li>提供较多的预定义组件，如Grid、Dialog、Form等常用组件。</li>\n<li>提供2套样式，支持Material Design。</li>\n<li>提供monaca脚手架，让项目搭建更方便。</li>\n<li>多框架语言的支持：React、Angular1/2、Vue2、Meteor。</li>\n<li>持续维护，更新及时。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>不包含但支持PhoneGap/Cordova构建。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<h4 id=\"Ionic\"><a href=\"#Ionic\" class=\"headerlink\" title=\"Ionic\"></a>Ionic</h4><p>使用Angular构建跨平台app。</p>\n<p>项目地址：<a href=\"https://github.com/driftyco/ionic\" target=\"_blank\" rel=\"external\">https://github.com/driftyco/ionic</a></p>\n<p>优势：</p>\n<ul>\n<li>提供Creator非代码环境拖拽组件构建App。</li>\n<li>提供丰富的预定义组件，如Grid、Modals、Input、Menus等组件。</li>\n<li>提供不同平台的样式选择和修改方式，支持Material Design。</li>\n<li>完善的文档，庞大的社区。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>必须会使用AngularJS去完成复杂的开发。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<h4 id=\"Framework_7\"><a href=\"#Framework_7\" class=\"headerlink\" title=\"Framework 7\"></a>Framework 7</h4><p>全功能的HTML框架，用于构建iOS和Android应用程序。针对IOS的UI设计，如果要兼容Android需要另外使用PhoneGap/Cordova。</p>\n<p>项目地址：<a href=\"https://github.com/nolimits4web/Framework7/\" target=\"_blank\" rel=\"external\">https://github.com/nolimits4web/Framework7/</a></p>\n<p>优势：</p>\n<ul>\n<li>丰富的示例、教程，容易上手。</li>\n<li>丰富的组件和插件。</li>\n<li>能够轻易和js框架配合使用，如React、Vue。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>不包含但支持PhoneGap/Cordova构建。</li>\n<li>没有提供脚手架，只提供了最基础的服务。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<h4 id=\"React_Native\"><a href=\"#React_Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h4><p>用React构建跨原生app，和PhoneGap/Cordov原理不一样，性能表现更流畅。</p>\n<p>项目地址：<a href=\"https://github.com/facebook/react-native\" target=\"_blank\" rel=\"external\">https://github.com/facebook/react-native</a></p>\n<p>优势：</p>\n<ul>\n<li>仿原生的表现，相对流畅。</li>\n<li>庞大的社区。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>学习曲线陡，需要适当学习客户端开发。</li>\n<li>跨平台的兼容性有待考究。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>稍微普及了PhoneGap/Cordova，是目前比较成熟和稳定的实现用JavaScript开发的Hybrid框架，但是由于还是通过WebView去展现，所以在性能方面还是不如原生Native来的流畅。</p>\n<p>对比当中混入了React Native，其实现原理和PhoneGap/Cordova没什么太大关系。目前很多人用React Native开发项目，从入门到放弃，目前还有太多兼容性和需要自定义的部分，开发成本比预期要来的高，要求开发者不仅会Web的技术，还需要IOS／Android的技术。</p>\n","excerpt":"<h3 id=\"Cordova__26amp_3B_PhoneGap__u5165_u95E8\"><a href=\"#Cordova__26amp_3B_PhoneGap__u5165_u95E8\" class=\"headerlink\" title=\"Cordova &amp; PhoneGap 入门\"></a>Cordova &amp; PhoneGap 入门</h3><p><code>Apacha Cordova</code>是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。<br><code>Apacha Cordova</code>是从<code>PhoneGap</code>中抽出的核心代码，是驱动<code>PhoneGap</code>的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。</p>\n<blockquote>\n<p>You can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. </p>\n</blockquote>\n<p>推荐阅读：<a href=\"http://phonegap.com/blog/2012/03/19/phonegap-cordova-and-whate28099s-in-a-name/\">PhoneGap, Cordova, and what’s in a name?</a></p>","more":"<h4 id=\"Cordova\"><a href=\"#Cordova\" class=\"headerlink\" title=\"Cordova\"></a>Cordova</h4><h5 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li><p>全局安装cordova。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g cordova</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">- 用cordova创建项目。</div><div class=\"line\">```code</div><div class=\"line\">$ cordova create hello com.example.hello HelloWorld</div></pre></td></tr></table></figure>\n</li>\n<li><p>增加平台platforms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova platform add ios --save</div><div class=\"line\">$ cordova platform add android --save</div><div class=\"line\"></div><div class=\"line\">// 查看平台</div><div class=\"line\">$ cordova platform ls</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装构建项目的环境，查看环境要求，之后按照步骤搭建起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova requirements</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;</div><div class=\"line\">Requirements check results for android:</div><div class=\"line\">Java JDK: installed 1.8.0</div><div class=\"line\">Android SDK: installed true</div><div class=\"line\">Android target: installed android-25</div><div class=\"line\">Gradle: installed </div><div class=\"line\"></div><div class=\"line\">Requirements check results for ios:</div><div class=\"line\">Apple OS X: installed darwin</div><div class=\"line\">Xcode: installed 8.1</div><div class=\"line\">ios-deploy: installed 1.9.1</div><div class=\"line\">CocoaPods: installed</div></pre></td></tr></table></figure>\n</li>\n<li><p>构建项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova build </div><div class=\"line\">// 或单独某个平台如IOS</div><div class=\"line\">$ cordova build ios</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装cordova插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova plugin add cordova-plugin-camera</div><div class=\"line\">// 查看项目插件</div><div class=\"line\">$ cordova plugin ls</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>重要插件地址: <a href=\"https://cordova.apache.org/docs/en/6.x/guide/support/index.html#core-plugin-apis\">core-plugin-apis</a><br>更多其他插件: <a href=\"http://www.plugreg.com/\">plugreg</a></p>\n<h5 id=\"u521B_u5EFA_u63D2_u4EF6\"><a href=\"#u521B_u5EFA_u63D2_u4EF6\" class=\"headerlink\" title=\"创建插件\"></a>创建插件</h5><p>插件必须配置<code>plugin.xml</code>文件，<code>id</code>表示插件名，<code>platform</code>对应当前配置的平台，<code>js-module</code>对应Javascript文件路径，<code>header-file</code>和<code>source-file</code>分别对应<code>.h</code>和<code>.m</code>文件。具体参数可以参考: <a href=\"https://cordova.apache.org/docs/en/6.x/plugin_ref/spec.html\">plugin.xml</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>plugman</code>检验当前插件是否能正确安装到各个平台。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g plugman</div><div class=\"line\">$ plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin</div></pre></td></tr></table></figure></p>\n<p>如果要写一个兼容Android/IOS的插件，需要会不同平台的语言，还是有点挑战的。具体的开发方式可以参照官网。发布直接通过npm的方式<code>npm publish</code>的方式即可，记得在发布之前新建<code>package.json</code>文件记录插件的各类信息。</p>\n<h4 id=\"PhoneGap\"><a href=\"#PhoneGap\" class=\"headerlink\" title=\"PhoneGap\"></a>PhoneGap</h4><p><code>PhoneGap</code>提供了桌面应用和通过<code>phonegap cli</code>来创建/操作项目，同时提供了移动端的调试工具，通过wifi连接即可。</p>\n<h5 id=\"u4F7F_u7528-1\"><a href=\"#u4F7F_u7528-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li><p>全局安装phonegap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g phonegap@latest</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建项目，通过客户端创建相对会慢很多，不指定模板默认<code>phonegap-template-hello-world</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap create myApp</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;</div><div class=\"line\">Creating a new cordova project.</div><div class=\"line\"></div><div class=\"line\">Using cordova-fetch for phonegap-template-hello-world</div></pre></td></tr></table></figure>\n</li>\n<li><p>增加平台platforms和插件plugin的命令和cordova类似，直接用cordova命令也是可以的。但在phonegap项目中在执行添加平台的命令会添加很多的常用的插件，需要等待一段时间，但是很大程度省去了安装插件的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap platform add ios</div><div class=\"line\"></div><div class=\"line\">$ phonegap plugin add cordova-plugin-device</div></pre></td></tr></table></figure>\n</li>\n<li><p>将项目拖拽到phonegap客户端界面，可自定义服务的端口，然后手机端连接项目查看效果。或者通过cli开启服务，不需要安装平台(ios/android/.etc)的依赖就可以直接看到效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ phonegap serve</div><div class=\"line\"></div><div class=\"line\">// 默认端口3000，可通过以下命令改变端口并开启服务</div><div class=\"line\">phonegap serve --port, -p &lt;n&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用插件，以拍照为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// html</div><div class=\"line\">&lt;div id=&quot;camera&quot;&gt;拍照&lt;div&gt;</div><div class=\"line\"></div><div class=\"line\">// JavaScript</div><div class=\"line\">// 插件调用都以 `navigator.插件名.方法`</div><div class=\"line\">var camera = document.getElementById(&apos;camera&apos;);</div><div class=\"line\">camaraButton.addEventListener(&apos;click&apos;, function()&#123;</div><div class=\"line\">    navigator.camera.getPicture(onLoadImageSuccess, onLoadImageFail);</div><div class=\"line\">&#125;, false);</div><div class=\"line\"></div><div class=\"line\">function onLoadImageSuccess(imageURI)&#123; // 成功返回图片地址</div><div class=\"line\">    alert(imageURI);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function onLoadImageFail(message)&#123; // 失败返回错误原因</div><div class=\"line\">    navigator.notification.alert(&quot;拍照失败，原因：&quot; + message, null, &quot;警告&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"u4E3B_u6D41Hybrid_u6846_u67B6_u5BF9_u6BD4\"><a href=\"#u4E3B_u6D41Hybrid_u6846_u67B6_u5BF9_u6BD4\" class=\"headerlink\" title=\"主流Hybrid框架对比\"></a>主流Hybrid框架对比</h3><h3 id=\"OnsenUI\"><a href=\"#OnsenUI\" class=\"headerlink\" title=\"OnsenUI\"></a>OnsenUI</h3><p>提供Angular 1, 2, React 和 Vue.js框架的移动端开发，还需要配合PhoneGap/Cordova实现跨平台开发。</p>\n<p>项目地址：<a href=\"https://github.com/OnsenUI/OnsenUI\">https://github.com/OnsenUI/OnsenUI</a></p>\n<p>优势：</p>\n<ul>\n<li>文档完善，提供丰富的示例。</li>\n<li>提供较多的预定义组件，如Grid、Dialog、Form等常用组件。</li>\n<li>提供2套样式，支持Material Design。</li>\n<li>提供monaca脚手架，让项目搭建更方便。</li>\n<li>多框架语言的支持：React、Angular1/2、Vue2、Meteor。</li>\n<li>持续维护，更新及时。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>不包含但支持PhoneGap/Cordova构建。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<h4 id=\"Ionic\"><a href=\"#Ionic\" class=\"headerlink\" title=\"Ionic\"></a>Ionic</h4><p>使用Angular构建跨平台app。</p>\n<p>项目地址：<a href=\"https://github.com/driftyco/ionic\">https://github.com/driftyco/ionic</a></p>\n<p>优势：</p>\n<ul>\n<li>提供Creator非代码环境拖拽组件构建App。</li>\n<li>提供丰富的预定义组件，如Grid、Modals、Input、Menus等组件。</li>\n<li>提供不同平台的样式选择和修改方式，支持Material Design。</li>\n<li>完善的文档，庞大的社区。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>必须会使用AngularJS去完成复杂的开发。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<h4 id=\"Framework_7\"><a href=\"#Framework_7\" class=\"headerlink\" title=\"Framework 7\"></a>Framework 7</h4><p>全功能的HTML框架，用于构建iOS和Android应用程序。针对IOS的UI设计，如果要兼容Android需要另外使用PhoneGap/Cordova。</p>\n<p>项目地址：<a href=\"https://github.com/nolimits4web/Framework7/\">https://github.com/nolimits4web/Framework7/</a></p>\n<p>优势：</p>\n<ul>\n<li>丰富的示例、教程，容易上手。</li>\n<li>丰富的组件和插件。</li>\n<li>能够轻易和js框架配合使用，如React、Vue。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>不包含但支持PhoneGap/Cordova构建。</li>\n<li>没有提供脚手架，只提供了最基础的服务。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<h4 id=\"React_Native\"><a href=\"#React_Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h4><p>用React构建跨原生app，和PhoneGap/Cordov原理不一样，性能表现更流畅。</p>\n<p>项目地址：<a href=\"https://github.com/facebook/react-native\">https://github.com/facebook/react-native</a></p>\n<p>优势：</p>\n<ul>\n<li>仿原生的表现，相对流畅。</li>\n<li>庞大的社区。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>学习曲线陡，需要适当学习客户端开发。</li>\n<li>跨平台的兼容性有待考究。</li>\n</ul>\n<p>推荐指数：🌟🌟🌟</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>稍微普及了PhoneGap/Cordova，是目前比较成熟和稳定的实现用JavaScript开发的Hybrid框架，但是由于还是通过WebView去展现，所以在性能方面还是不如原生Native来的流畅。</p>\n<p>对比当中混入了React Native，其实现原理和PhoneGap/Cordova没什么太大关系。目前很多人用React Native开发项目，从入门到放弃，目前还有太多兼容性和需要自定义的部分，开发成本比预期要来的高，要求开发者不仅会Web的技术，还需要IOS／Android的技术。</p>"},{"title":"React组件单元测试","date":"2017-01-18T03:25:02.000Z","banner":"https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg","_content":"\n针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\n\n### Test Utilities\n#### Shallow Rendering - 浅渲染\nShallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。\n<!-- more -->\n函数shallowRender返回浅渲染的虚拟DOM对象：\n```code\nimport TestUtils from 'react/lib/ReactTestUtils.js';\n\nfunction shallowRender(Component, props){\n    const renderer = TestUtils.createRenderer();\n    renderer.render(<Component {...props}/>);\n    return renderer.getRenderOutput();\n}\n```\n浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：\n```code\nimport React from 'react';\nimport assert from 'assert';\nimport Button from '../src/Button';\n\ndescribe(\"<Button/>\", function(){\n    it('phStyle设置为primary', ()=>{\n        const button = shallowRender(<Button phStyle='primary'></Button>);\n        assert(button.props.className.match('primary'));\n    });\n});\n```\n\n#### renderIntoDocument - 将element渲染成真实的DOM节点\nrenderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：\n```code\n// ...\nimport {findDOMNode} from 'react-dom';\nimport Switch from '../src/Switch';\n\ndescribe(\"<Switch/>\", function(){\n    it('改变时触发onChange', ()=>{\n        let checked = true;\n        const switchs = TestUtils.renderIntoDocument(<Switch checked={checked} onChange={()=>{checked=false}} />);\n        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, 'input')[0];\n\n        TestUtils.Simulate.change(checkbox);\n        assert.equal(checked, false);\n    });\n});\n```\n初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。\n\n#### Simulate - 模拟用户操作\n`Simulate.{eventName}(element,[eventData])`将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。\n```code\nTestUtils.Simulate.click(node);\nTestUtils.Simulate.change(node);\nTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n```\n\n#### 节点查找\nTest Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对`props.children`进行查找。\n##### 虚拟DOM的节点查找\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallowRender(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.props.children[1].props.children, label);\n});\n// ...\n```\n`checkbox.props.children[1].props.children`查找的是第二个子元素的内容。\n\n##### 真实DOM的节点查找\n对于真实DOM节点，可以是JavaScript原生的一些方法，如`findDOMNode(node).querySelector(...)`。以下是Test Utilities提供的方法：\n-   scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点\n-   findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点\n-   findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedComponentsWithType：找出所有符合指定子组件的节点\n-   findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点\n\n更多信息：[Test Utilities](https://facebook.github.io/react/docs/test-utils.html)\n\n### Enzyme\nEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。\n#### 使用\n正式使用前有几点需要注意，否则会报错。\n-   首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：\n\t```code\n\t/* webpack.config.js for React 0.14 */\n\t// ...\n\texternals: {\n\t  'cheerio': 'window',\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n\t```code\n\t/* webpack.config.js for React 15 */\n\t// ...\n\texternals: {\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n更多信息：[enzyme-guides](http://airbnb.io/enzyme/docs/guides/webpack.html)\n\n-   针对不同版本React的安装\n\t```code\n\t/* React 0.13 */\n\tnpm i react@0.13 --save\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 0.14 */\n\tnpm i --save react@0.14 react-dom@0.14\n\tnpm i --save-dev react-addons-test-utils@0.14\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 15 */\n\tnpm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2\n\tnpm i --save-dev react-addons-test-utils@15.0.0-rc.2\n\tnpm i --save-dev enzyme\n\t```\n更多信息：[enzyme-installation](http://airbnb.io/enzyme/docs/installation/index.html)\n\n#### API\n##### shallow\nshallow方法是对Shallow Rendering的封装，同一个例子，获取`className`的方法通过`props()`方法返回。\n```code\n// ...\nit('phStyle设置为primary', ()=>{\n    const button = shallow(<Button phStyle='primary'>btn</Button>);\n    assert(button.props().className.match('primary'));\n});\n// ...\n```\n同一个例子，使用`find()`方法查找子节点，`text()`方法获取文本内容。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallow(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n\n##### mount\nmount将React组件加载为真实的DOM节点。和shallow的api相同，用`find()`方法查找子节点，模拟用户操作的方法封装为`simulate(enentType)`。\n```code\n// ...\nit('改变时触发onChange', ()=>{\n    let checked = true;\n    const switchs = mount(<Switch checked={checked} onChange={()=>{checked=false}} />);\n    \n    switchs.find('input').simulate('change');\n    assert.equal(checked, false);\n});\n// ...\n```\n\n##### render\nrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = render(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n使用render方法时碰到一个错误：`_cheerio2.default.load is not a function`，还是比较普遍的，跟webpack配置有关系，修改如下：\n```code\nexternals: {\n        'jsdom': 'window',\n        // 'cheerio': 'window',\n        // ...\n    },\n    module:{\n        loaders:[\n            // ...\n            {\n                test: /\\.json$/,\n                loader: 'json',\n            }\n        ]\n    }\n```\n\n更多信息：[enzyme-api](http://airbnb.io/enzyme/docs/api/index.html)\n\n### 其他\n#### Jest\nJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。\n> Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.\n\n普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。\n\n更多信息：[jest-react-tutorial](https://facebook.github.io/jest/docs/tutorial-react.html)\n\n### 总结\n其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄\n\n","source":"_posts/React组件单元测试.md","raw":"---\ntitle: React组件单元测试\ndate: 2017-01-18 11:25:02\nbanner: https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/test-utilities/react_component_unit_test.jpg\ntags:\n- react\n- test\n- 陈小饼\ncategories:\n- react\n- test\n---\n\n针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\n\n### Test Utilities\n#### Shallow Rendering - 浅渲染\nShallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。\n<!-- more -->\n函数shallowRender返回浅渲染的虚拟DOM对象：\n```code\nimport TestUtils from 'react/lib/ReactTestUtils.js';\n\nfunction shallowRender(Component, props){\n    const renderer = TestUtils.createRenderer();\n    renderer.render(<Component {...props}/>);\n    return renderer.getRenderOutput();\n}\n```\n浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：\n```code\nimport React from 'react';\nimport assert from 'assert';\nimport Button from '../src/Button';\n\ndescribe(\"<Button/>\", function(){\n    it('phStyle设置为primary', ()=>{\n        const button = shallowRender(<Button phStyle='primary'></Button>);\n        assert(button.props.className.match('primary'));\n    });\n});\n```\n\n#### renderIntoDocument - 将element渲染成真实的DOM节点\nrenderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：\n```code\n// ...\nimport {findDOMNode} from 'react-dom';\nimport Switch from '../src/Switch';\n\ndescribe(\"<Switch/>\", function(){\n    it('改变时触发onChange', ()=>{\n        let checked = true;\n        const switchs = TestUtils.renderIntoDocument(<Switch checked={checked} onChange={()=>{checked=false}} />);\n        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, 'input')[0];\n\n        TestUtils.Simulate.change(checkbox);\n        assert.equal(checked, false);\n    });\n});\n```\n初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。\n\n#### Simulate - 模拟用户操作\n`Simulate.{eventName}(element,[eventData])`将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。\n```code\nTestUtils.Simulate.click(node);\nTestUtils.Simulate.change(node);\nTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n```\n\n#### 节点查找\nTest Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对`props.children`进行查找。\n##### 虚拟DOM的节点查找\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallowRender(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.props.children[1].props.children, label);\n});\n// ...\n```\n`checkbox.props.children[1].props.children`查找的是第二个子元素的内容。\n\n##### 真实DOM的节点查找\n对于真实DOM节点，可以是JavaScript原生的一些方法，如`findDOMNode(node).querySelector(...)`。以下是Test Utilities提供的方法：\n-   scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点\n-   findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点\n-   findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   scryRenderedComponentsWithType：找出所有符合指定子组件的节点\n-   findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错\n-   findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点\n\n更多信息：[Test Utilities](https://facebook.github.io/react/docs/test-utils.html)\n\n### Enzyme\nEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。\n#### 使用\n正式使用前有几点需要注意，否则会报错。\n-   首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：\n\t```code\n\t/* webpack.config.js for React 0.14 */\n\t// ...\n\texternals: {\n\t  'cheerio': 'window',\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n\t```code\n\t/* webpack.config.js for React 15 */\n\t// ...\n\texternals: {\n\t  'react/addons': true,\n\t  'react/lib/ExecutionEnvironment': true,\n\t  'react/lib/ReactContext': true\n\t}\n\t// ...\n\t```\n更多信息：[enzyme-guides](http://airbnb.io/enzyme/docs/guides/webpack.html)\n\n-   针对不同版本React的安装\n\t```code\n\t/* React 0.13 */\n\tnpm i react@0.13 --save\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 0.14 */\n\tnpm i --save react@0.14 react-dom@0.14\n\tnpm i --save-dev react-addons-test-utils@0.14\n\tnpm i --save-dev enzyme\n\t```\n\t```code\n\t/* React 15 */\n\tnpm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2\n\tnpm i --save-dev react-addons-test-utils@15.0.0-rc.2\n\tnpm i --save-dev enzyme\n\t```\n更多信息：[enzyme-installation](http://airbnb.io/enzyme/docs/installation/index.html)\n\n#### API\n##### shallow\nshallow方法是对Shallow Rendering的封装，同一个例子，获取`className`的方法通过`props()`方法返回。\n```code\n// ...\nit('phStyle设置为primary', ()=>{\n    const button = shallow(<Button phStyle='primary'>btn</Button>);\n    assert(button.props().className.match('primary'));\n});\n// ...\n```\n同一个例子，使用`find()`方法查找子节点，`text()`方法获取文本内容。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = shallow(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n\n##### mount\nmount将React组件加载为真实的DOM节点。和shallow的api相同，用`find()`方法查找子节点，模拟用户操作的方法封装为`simulate(enentType)`。\n```code\n// ...\nit('改变时触发onChange', ()=>{\n    let checked = true;\n    const switchs = mount(<Switch checked={checked} onChange={()=>{checked=false}} />);\n    \n    switchs.find('input').simulate('change');\n    assert.equal(checked, false);\n});\n// ...\n```\n\n##### render\nrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。\n```code\n// ...\nit('checkbox: label传值显示正常', ()=>{\n    let label = '测试';\n    const checkbox = render(<Input type='checkbox' label={label} />);\n\n    assert.equal(checkbox.find('span').text(), label);\n});\n// ...\n```\n使用render方法时碰到一个错误：`_cheerio2.default.load is not a function`，还是比较普遍的，跟webpack配置有关系，修改如下：\n```code\nexternals: {\n        'jsdom': 'window',\n        // 'cheerio': 'window',\n        // ...\n    },\n    module:{\n        loaders:[\n            // ...\n            {\n                test: /\\.json$/,\n                loader: 'json',\n            }\n        ]\n    }\n```\n\n更多信息：[enzyme-api](http://airbnb.io/enzyme/docs/api/index.html)\n\n### 其他\n#### Jest\nJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。\n> Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.\n\n普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。\n\n更多信息：[jest-react-tutorial](https://facebook.github.io/jest/docs/tutorial-react.html)\n\n### 总结\n其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄\n\n","slug":"React组件单元测试","published":1,"updated":"2017-01-24T07:41:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gwzzzo00050o85co70f7vq","content":"<p>针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。</p>\n<h3 id=\"Test_Utilities\"><a href=\"#Test_Utilities\" class=\"headerlink\" title=\"Test Utilities\"></a>Test Utilities</h3><h4 id=\"Shallow_Rendering_-__u6D45_u6E32_u67D3\"><a href=\"#Shallow_Rendering_-__u6D45_u6E32_u67D3\" class=\"headerlink\" title=\"Shallow Rendering - 浅渲染\"></a>Shallow Rendering - 浅渲染</h4><p>Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。<br><a id=\"more\"></a><br>函数shallowRender返回浅渲染的虚拟DOM对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;</div><div class=\"line\"></div><div class=\"line\">function shallowRender(Component, props)&#123;</div><div class=\"line\">    const renderer = TestUtils.createRenderer();</div><div class=\"line\">    renderer.render(&lt;Component &#123;...props&#125;/&gt;);</div><div class=\"line\">    return renderer.getRenderOutput();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React from &apos;react&apos;;</div><div class=\"line\">import assert from &apos;assert&apos;;</div><div class=\"line\">import Button from &apos;../src/Button&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Button/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">        const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;);</div><div class=\"line\">        assert(button.props.className.match(&apos;primary&apos;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\"><a href=\"#renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\" class=\"headerlink\" title=\"renderIntoDocument - 将element渲染成真实的DOM节点\"></a>renderIntoDocument - 将element渲染成真实的DOM节点</h4><p>renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">import &#123;findDOMNode&#125; from &apos;react-dom&apos;;</div><div class=\"line\">import Switch from &apos;../src/Switch&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Switch/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">        let checked = true;</div><div class=\"line\">        const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0];</div><div class=\"line\"></div><div class=\"line\">        TestUtils.Simulate.change(checkbox);</div><div class=\"line\">        assert.equal(checked, false);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。</p>\n<h4 id=\"Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\"><a href=\"#Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\" class=\"headerlink\" title=\"Simulate - 模拟用户操作\"></a>Simulate - 模拟用户操作</h4><p><code>Simulate.{eventName}(element,[eventData])</code>将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestUtils.Simulate.click(node);</div><div class=\"line\">TestUtils.Simulate.change(node);</div><div class=\"line\">TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"u8282_u70B9_u67E5_u627E\"><a href=\"#u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"节点查找\"></a>节点查找</h4><p>Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对<code>props.children</code>进行查找。</p>\n<h5 id=\"u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"虚拟DOM的节点查找\"></a>虚拟DOM的节点查找</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.props.children[1].props.children, label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<p><code>checkbox.props.children[1].props.children</code>查找的是第二个子元素的内容。</p>\n<h5 id=\"u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"真实DOM的节点查找\"></a>真实DOM的节点查找</h5><p>对于真实DOM节点，可以是JavaScript原生的一些方法，如<code>findDOMNode(node).querySelector(...)</code>。以下是Test Utilities提供的方法：</p>\n<ul>\n<li>scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点</li>\n<li>findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点</li>\n<li>findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedComponentsWithType：找出所有符合指定子组件的节点</li>\n<li>findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点</li>\n</ul>\n<p>更多信息：<a href=\"https://facebook.github.io/react/docs/test-utils.html\" target=\"_blank\" rel=\"external\">Test Utilities</a></p>\n<h3 id=\"Enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h3><p>Enzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。</p>\n<h4 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>正式使用前有几点需要注意，否则会报错。</p>\n<ul>\n<li><p>首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 0.14 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 15 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/guides/webpack.html\" target=\"_blank\" rel=\"external\">enzyme-guides</a></p>\n<ul>\n<li><p>针对不同版本React的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.13 */</div><div class=\"line\">npm i react@0.13 --save</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.14 */</div><div class=\"line\">npm i --save react@0.14 react-dom@0.14</div><div class=\"line\">npm i --save-dev react-addons-test-utils@0.14</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 15 */</div><div class=\"line\">npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev react-addons-test-utils@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/installation/index.html\" target=\"_blank\" rel=\"external\">enzyme-installation</a></p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><h5 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h5><p>shallow方法是对Shallow Rendering的封装，同一个例子，获取<code>className</code>的方法通过<code>props()</code>方法返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">    const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;);</div><div class=\"line\">    assert(button.props().className.match(&apos;primary&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>同一个例子，使用<code>find()</code>方法查找子节点，<code>text()</code>方法获取文本内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h5><p>mount将React组件加载为真实的DOM节点。和shallow的api相同，用<code>find()</code>方法查找子节点，模拟用户操作的方法封装为<code>simulate(enentType)</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">    let checked = true;</div><div class=\"line\">    const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">    </div><div class=\"line\">    switchs.find(&apos;input&apos;).simulate(&apos;change&apos;);</div><div class=\"line\">    assert.equal(checked, false);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>render方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>使用render方法时碰到一个错误：<code>_cheerio2.default.load is not a function</code>，还是比较普遍的，跟webpack配置有关系，修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">        &apos;jsdom&apos;: &apos;window&apos;,</div><div class=\"line\">        // &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module:&#123;</div><div class=\"line\">        loaders:[</div><div class=\"line\">            // ...</div><div class=\"line\">            &#123;</div><div class=\"line\">                test: /\\.json$/,</div><div class=\"line\">                loader: &apos;json&apos;,</div><div class=\"line\">            &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/api/index.html\" target=\"_blank\" rel=\"external\">enzyme-api</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。</p>\n<blockquote>\n<p>Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.</p>\n</blockquote>\n<p>普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。</p>\n<p>更多信息：<a href=\"https://facebook.github.io/jest/docs/tutorial-react.html\" target=\"_blank\" rel=\"external\">jest-react-tutorial</a></p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄</p>\n","excerpt":"<p>针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。</p>\n<h3 id=\"Test_Utilities\"><a href=\"#Test_Utilities\" class=\"headerlink\" title=\"Test Utilities\"></a>Test Utilities</h3><h4 id=\"Shallow_Rendering_-__u6D45_u6E32_u67D3\"><a href=\"#Shallow_Rendering_-__u6D45_u6E32_u67D3\" class=\"headerlink\" title=\"Shallow Rendering - 浅渲染\"></a>Shallow Rendering - 浅渲染</h4><p>Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。<br>","more":"<br>函数shallowRender返回浅渲染的虚拟DOM对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;</div><div class=\"line\"></div><div class=\"line\">function shallowRender(Component, props)&#123;</div><div class=\"line\">    const renderer = TestUtils.createRenderer();</div><div class=\"line\">    renderer.render(&lt;Component &#123;...props&#125;/&gt;);</div><div class=\"line\">    return renderer.getRenderOutput();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React from &apos;react&apos;;</div><div class=\"line\">import assert from &apos;assert&apos;;</div><div class=\"line\">import Button from &apos;../src/Button&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Button/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">        const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;);</div><div class=\"line\">        assert(button.props.className.match(&apos;primary&apos;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\"><a href=\"#renderIntoDocument_-__u5C06element_u6E32_u67D3_u6210_u771F_u5B9E_u7684DOM_u8282_u70B9\" class=\"headerlink\" title=\"renderIntoDocument - 将element渲染成真实的DOM节点\"></a>renderIntoDocument - 将element渲染成真实的DOM节点</h4><p>renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">import &#123;findDOMNode&#125; from &apos;react-dom&apos;;</div><div class=\"line\">import Switch from &apos;../src/Switch&apos;;</div><div class=\"line\"></div><div class=\"line\">describe(&quot;&lt;Switch/&gt;&quot;, function()&#123;</div><div class=\"line\">    it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">        let checked = true;</div><div class=\"line\">        const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">        const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0];</div><div class=\"line\"></div><div class=\"line\">        TestUtils.Simulate.change(checkbox);</div><div class=\"line\">        assert.equal(checked, false);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。</p>\n<h4 id=\"Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\"><a href=\"#Simulate_-__u6A21_u62DF_u7528_u6237_u64CD_u4F5C\" class=\"headerlink\" title=\"Simulate - 模拟用户操作\"></a>Simulate - 模拟用户操作</h4><p><code>Simulate.{eventName}(element,[eventData])</code>将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestUtils.Simulate.click(node);</div><div class=\"line\">TestUtils.Simulate.change(node);</div><div class=\"line\">TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"u8282_u70B9_u67E5_u627E\"><a href=\"#u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"节点查找\"></a>节点查找</h4><p>Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对<code>props.children</code>进行查找。</p>\n<h5 id=\"u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u865A_u62DFDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"虚拟DOM的节点查找\"></a>虚拟DOM的节点查找</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.props.children[1].props.children, label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<p><code>checkbox.props.children[1].props.children</code>查找的是第二个子元素的内容。</p>\n<h5 id=\"u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\"><a href=\"#u771F_u5B9EDOM_u7684_u8282_u70B9_u67E5_u627E\" class=\"headerlink\" title=\"真实DOM的节点查找\"></a>真实DOM的节点查找</h5><p>对于真实DOM节点，可以是JavaScript原生的一些方法，如<code>findDOMNode(node).querySelector(...)</code>。以下是Test Utilities提供的方法：</p>\n<ul>\n<li>scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点</li>\n<li>findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点</li>\n<li>findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>scryRenderedComponentsWithType：找出所有符合指定子组件的节点</li>\n<li>findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错</li>\n<li>findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点</li>\n</ul>\n<p>更多信息：<a href=\"https://facebook.github.io/react/docs/test-utils.html\">Test Utilities</a></p>\n<h3 id=\"Enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h3><p>Enzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。</p>\n<h4 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>正式使用前有几点需要注意，否则会报错。</p>\n<ul>\n<li><p>首先，对于webpack的使用者，对于不同的React版本，配置中需要加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 0.14 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* webpack.config.js for React 15 */</div><div class=\"line\">// ...</div><div class=\"line\">externals: &#123;</div><div class=\"line\">  &apos;react/addons&apos;: true,</div><div class=\"line\">  &apos;react/lib/ExecutionEnvironment&apos;: true,</div><div class=\"line\">  &apos;react/lib/ReactContext&apos;: true</div><div class=\"line\">&#125;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/guides/webpack.html\">enzyme-guides</a></p>\n<ul>\n<li><p>针对不同版本React的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.13 */</div><div class=\"line\">npm i react@0.13 --save</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 0.14 */</div><div class=\"line\">npm i --save react@0.14 react-dom@0.14</div><div class=\"line\">npm i --save-dev react-addons-test-utils@0.14</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* React 15 */</div><div class=\"line\">npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev react-addons-test-utils@15.0.0-rc.2</div><div class=\"line\">npm i --save-dev enzyme</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/installation/index.html\">enzyme-installation</a></p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><h5 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h5><p>shallow方法是对Shallow Rendering的封装，同一个例子，获取<code>className</code>的方法通过<code>props()</code>方法返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123;</div><div class=\"line\">    const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;);</div><div class=\"line\">    assert(button.props().className.match(&apos;primary&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>同一个例子，使用<code>find()</code>方法查找子节点，<code>text()</code>方法获取文本内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h5><p>mount将React组件加载为真实的DOM节点。和shallow的api相同，用<code>find()</code>方法查找子节点，模拟用户操作的方法封装为<code>simulate(enentType)</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;改变时触发onChange&apos;, ()=&gt;&#123;</div><div class=\"line\">    let checked = true;</div><div class=\"line\">    const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;);</div><div class=\"line\">    </div><div class=\"line\">    switchs.find(&apos;input&apos;).simulate(&apos;change&apos;);</div><div class=\"line\">    assert.equal(checked, false);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>render方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ...</div><div class=\"line\">it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123;</div><div class=\"line\">    let label = &apos;测试&apos;;</div><div class=\"line\">    const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;);</div><div class=\"line\"></div><div class=\"line\">    assert.equal(checkbox.find(&apos;span&apos;).text(), label);</div><div class=\"line\">&#125;);</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>使用render方法时碰到一个错误：<code>_cheerio2.default.load is not a function</code>，还是比较普遍的，跟webpack配置有关系，修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">        &apos;jsdom&apos;: &apos;window&apos;,</div><div class=\"line\">        // &apos;cheerio&apos;: &apos;window&apos;,</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module:&#123;</div><div class=\"line\">        loaders:[</div><div class=\"line\">            // ...</div><div class=\"line\">            &#123;</div><div class=\"line\">                test: /\\.json$/,</div><div class=\"line\">                loader: &apos;json&apos;,</div><div class=\"line\">            &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>更多信息：<a href=\"http://airbnb.io/enzyme/docs/api/index.html\">enzyme-api</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。</p>\n<blockquote>\n<p>Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.</p>\n</blockquote>\n<p>普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。</p>\n<p>更多信息：<a href=\"https://facebook.github.io/jest/docs/tutorial-react.html\">jest-react-tutorial</a></p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄</p>"},{"title":"XMLHttpRequest","date":"2016-12-30T02:28:11.000Z","_content":"### Ajax & XMLHttpRequest\n\najax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。\n\n![what_is_ajax](https://alisonchenab.github.io/images/what_is_ajax.png)\n\n### XMLHttpRequest发展历程\n\n#### level1缺点：\n\n1. 只支持文本数据的传送，无法用来读取和上传二进制文件。\n2. 传送和接收数据时，没有进度信息，只能提示有没有完成。\n3. 受到\"同域限制\"，只能向同一域名的服务器请求数据。\n\n#### level2改进点：\n\n1. 可以设置HTTP请求的时限。\n2. 可以使用FormData对象管理表单数据。\n3. 可以上传文件。\n4. 可以请求不同域名下的数据（跨域请求）。\n5. 可以获取服务器端的二进制数据。\n6. 可以获得数据传输的进度信息。\n\n### XMLHttpRequest使用\n\n```code\n\nfunction sendAjax(data) {\n    // 创建xhr对象\n    var xhr = new XMLHttpRequest();\n    // 设置xhr请求的超时时间\n    xhr.timeout = 3000;\n    // 设置响应返回的超时时间\n    xhr.responseType = 'text';\n    // 创建一个post请求,采用异步\n    xhr.open('POST', '/server', true);\n    // 注册相关事件回调处理函数\n    xhr.onload = function(e){\n        if(this.status == 200 || this.status == 304){\n            alert(this.responseText);\n        }\n    };\n    xhr.ontimeout = function(e) {}\n    xhr.onerror = function(e) {}\n    xhr.upload.onprogress = function(e) {}\n\n    // 发送数据\n    xhr.send(data);\n}\n\n```\n\n\n","source":"_posts/XMLHttpRequest.md","raw":"---\ntitle: XMLHttpRequest\ndate: 2016-12-30 10:28:11\ntags:\n- http\ncategories:\n- http\n---\n### Ajax & XMLHttpRequest\n\najax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。\n\n![what_is_ajax](https://alisonchenab.github.io/images/what_is_ajax.png)\n\n### XMLHttpRequest发展历程\n\n#### level1缺点：\n\n1. 只支持文本数据的传送，无法用来读取和上传二进制文件。\n2. 传送和接收数据时，没有进度信息，只能提示有没有完成。\n3. 受到\"同域限制\"，只能向同一域名的服务器请求数据。\n\n#### level2改进点：\n\n1. 可以设置HTTP请求的时限。\n2. 可以使用FormData对象管理表单数据。\n3. 可以上传文件。\n4. 可以请求不同域名下的数据（跨域请求）。\n5. 可以获取服务器端的二进制数据。\n6. 可以获得数据传输的进度信息。\n\n### XMLHttpRequest使用\n\n```code\n\nfunction sendAjax(data) {\n    // 创建xhr对象\n    var xhr = new XMLHttpRequest();\n    // 设置xhr请求的超时时间\n    xhr.timeout = 3000;\n    // 设置响应返回的超时时间\n    xhr.responseType = 'text';\n    // 创建一个post请求,采用异步\n    xhr.open('POST', '/server', true);\n    // 注册相关事件回调处理函数\n    xhr.onload = function(e){\n        if(this.status == 200 || this.status == 304){\n            alert(this.responseText);\n        }\n    };\n    xhr.ontimeout = function(e) {}\n    xhr.onerror = function(e) {}\n    xhr.upload.onprogress = function(e) {}\n\n    // 发送数据\n    xhr.send(data);\n}\n\n```\n\n\n","slug":"XMLHttpRequest","published":1,"updated":"2017-01-24T07:41:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gwzzzt00060o852mxth1tc","content":"<h3 id=\"Ajax__26amp_3B_XMLHttpRequest\"><a href=\"#Ajax__26amp_3B_XMLHttpRequest\" class=\"headerlink\" title=\"Ajax &amp; XMLHttpRequest\"></a>Ajax &amp; XMLHttpRequest</h3><p>ajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。</p>\n<p><img src=\"https://alisonchenab.github.io/images/what_is_ajax.png\" alt=\"what_is_ajax\"></p>\n<h3 id=\"XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\"><a href=\"#XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\" class=\"headerlink\" title=\"XMLHttpRequest发展历程\"></a>XMLHttpRequest发展历程</h3><h4 id=\"level1_u7F3A_u70B9_uFF1A\"><a href=\"#level1_u7F3A_u70B9_uFF1A\" class=\"headerlink\" title=\"level1缺点：\"></a>level1缺点：</h4><ol>\n<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>\n<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>\n<li>受到”同域限制”，只能向同一域名的服务器请求数据。</li>\n</ol>\n<h4 id=\"level2_u6539_u8FDB_u70B9_uFF1A\"><a href=\"#level2_u6539_u8FDB_u70B9_uFF1A\" class=\"headerlink\" title=\"level2改进点：\"></a>level2改进点：</h4><ol>\n<li>可以设置HTTP请求的时限。</li>\n<li>可以使用FormData对象管理表单数据。</li>\n<li>可以上传文件。</li>\n<li>可以请求不同域名下的数据（跨域请求）。</li>\n<li>可以获取服务器端的二进制数据。</li>\n<li>可以获得数据传输的进度信息。</li>\n</ol>\n<h3 id=\"XMLHttpRequest_u4F7F_u7528\"><a href=\"#XMLHttpRequest_u4F7F_u7528\" class=\"headerlink\" title=\"XMLHttpRequest使用\"></a>XMLHttpRequest使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function sendAjax(data) &#123;</div><div class=\"line\">    // 创建xhr对象</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    // 设置xhr请求的超时时间</div><div class=\"line\">    xhr.timeout = 3000;</div><div class=\"line\">    // 设置响应返回的超时时间</div><div class=\"line\">    xhr.responseType = &apos;text&apos;;</div><div class=\"line\">    // 创建一个post请求,采用异步</div><div class=\"line\">    xhr.open(&apos;POST&apos;, &apos;/server&apos;, true);</div><div class=\"line\">    // 注册相关事件回调处理函数</div><div class=\"line\">    xhr.onload = function(e)&#123;</div><div class=\"line\">        if(this.status == 200 || this.status == 304)&#123;</div><div class=\"line\">            alert(this.responseText);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    xhr.ontimeout = function(e) &#123;&#125;</div><div class=\"line\">    xhr.onerror = function(e) &#123;&#125;</div><div class=\"line\">    xhr.upload.onprogress = function(e) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    // 发送数据</div><div class=\"line\">    xhr.send(data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"Ajax__26amp_3B_XMLHttpRequest\"><a href=\"#Ajax__26amp_3B_XMLHttpRequest\" class=\"headerlink\" title=\"Ajax &amp; XMLHttpRequest\"></a>Ajax &amp; XMLHttpRequest</h3><p>ajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。</p>\n<p><img src=\"https://alisonchenab.github.io/images/what_is_ajax.png\" alt=\"what_is_ajax\"></p>\n<h3 id=\"XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\"><a href=\"#XMLHttpRequest_u53D1_u5C55_u5386_u7A0B\" class=\"headerlink\" title=\"XMLHttpRequest发展历程\"></a>XMLHttpRequest发展历程</h3><h4 id=\"level1_u7F3A_u70B9_uFF1A\"><a href=\"#level1_u7F3A_u70B9_uFF1A\" class=\"headerlink\" title=\"level1缺点：\"></a>level1缺点：</h4><ol>\n<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>\n<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>\n<li>受到”同域限制”，只能向同一域名的服务器请求数据。</li>\n</ol>\n<h4 id=\"level2_u6539_u8FDB_u70B9_uFF1A\"><a href=\"#level2_u6539_u8FDB_u70B9_uFF1A\" class=\"headerlink\" title=\"level2改进点：\"></a>level2改进点：</h4><ol>\n<li>可以设置HTTP请求的时限。</li>\n<li>可以使用FormData对象管理表单数据。</li>\n<li>可以上传文件。</li>\n<li>可以请求不同域名下的数据（跨域请求）。</li>\n<li>可以获取服务器端的二进制数据。</li>\n<li>可以获得数据传输的进度信息。</li>\n</ol>\n<h3 id=\"XMLHttpRequest_u4F7F_u7528\"><a href=\"#XMLHttpRequest_u4F7F_u7528\" class=\"headerlink\" title=\"XMLHttpRequest使用\"></a>XMLHttpRequest使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function sendAjax(data) &#123;</div><div class=\"line\">    // 创建xhr对象</div><div class=\"line\">    var xhr = new XMLHttpRequest();</div><div class=\"line\">    // 设置xhr请求的超时时间</div><div class=\"line\">    xhr.timeout = 3000;</div><div class=\"line\">    // 设置响应返回的超时时间</div><div class=\"line\">    xhr.responseType = &apos;text&apos;;</div><div class=\"line\">    // 创建一个post请求,采用异步</div><div class=\"line\">    xhr.open(&apos;POST&apos;, &apos;/server&apos;, true);</div><div class=\"line\">    // 注册相关事件回调处理函数</div><div class=\"line\">    xhr.onload = function(e)&#123;</div><div class=\"line\">        if(this.status == 200 || this.status == 304)&#123;</div><div class=\"line\">            alert(this.responseText);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    xhr.ontimeout = function(e) &#123;&#125;</div><div class=\"line\">    xhr.onerror = function(e) &#123;&#125;</div><div class=\"line\">    xhr.upload.onprogress = function(e) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    // 发送数据</div><div class=\"line\">    xhr.send(data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"Yarn-模块管理工具","date":"2017-01-11T11:39:50.000Z","banner":"https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg","_content":"\n### 简介\n2016年10月11日，facebook发布新的模块管理工具Yarn。   \n随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n-   安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n-   允许安装packages时执行代码，埋下安全隐患。\n-   安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。\n<!-- more -->\n\n### Yarn vs NPM\n#### yarn.lock\nNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：\n\n-   指定版本号（1.2.2）：只安装指定版本\n-   波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）\n-   插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）\n\n当执行`npm install [package] --save`时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。\n\nyarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的`npm-shrinkwrap.json`，需要通过执行 `npm shrinkwrap` 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。\n\n#### 更快的模块下载\nyarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。\n\n以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）\n\n除此，yarn还支持离线下载，前提是之前下过这个包。\n\n对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：\n```code\n$ yarn config set registry 'https://registry.npm.taobao.org'\n```\n\n#### 更简洁的输出\nyarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。\n\n更多信息：[migrating-from-npm](https://yarnpkg.com/en/docs/migrating-from-npm)\n\n\n### 使用\n#### 安装\n```code\n// 用Homebrew安装\n$ brew update\n$ brew install yarn\n\n// 用NPM安装\n$ npm install yarn -g\n```\n\n#### CLI\n##### 安装依赖\n安装package.json的依赖\n```code\n$ yarn\nor\n$ yarn install\n```\n\n本地安装某个模块依赖\n```code\n$ yarn add [package] \n->$ npm install [package] --save\n\n$ yarn add [package] [--dev/-D]\n->$ npm install --save-dev [package]\n```\n\n全局安装\n```code\n$ yarn global add [package]\n->$ npm install [--global/-g] [package]\n```\n\n##### 删除依赖\n```code\n$ yarn remove [package]\n->$ npm uninstall --save [package]\n```\n\n##### 升级依赖\n根据package.json文件重新安装到当前配置的最新版本\n```code\n$ yarn upgrade\n->$ rm -rf node_modules && npm install\n```\n\n更多与NPM的CLI对比：[cli-commands-comparison](https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison)\n更多CLI介绍：[cli-introduction](https://yarnpkg.com/en/docs/cli/)\n\n### 其他\n提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。\n\n### 总结\n好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。\n\n","source":"_posts/Yarn-模块管理工具.md","raw":"title: Yarn-模块管理工具\ndate: 2017-01-11 19:39:50\nbanner: https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/yarn/banner_yarn.jpg\ntags: \n- Yarn\n- NPM\n- 工具\n- 陈小饼\ncategories:\n- yarn\n- npm\n- 工具\n---\n\n### 简介\n2016年10月11日，facebook发布新的模块管理工具Yarn。   \n随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n-   安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n-   允许安装packages时执行代码，埋下安全隐患。\n-   安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。\n<!-- more -->\n\n### Yarn vs NPM\n#### yarn.lock\nNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：\n\n-   指定版本号（1.2.2）：只安装指定版本\n-   波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）\n-   插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）\n\n当执行`npm install [package] --save`时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。\n\nyarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的`npm-shrinkwrap.json`，需要通过执行 `npm shrinkwrap` 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。\n\n#### 更快的模块下载\nyarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。\n\n以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）\n\n除此，yarn还支持离线下载，前提是之前下过这个包。\n\n对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：\n```code\n$ yarn config set registry 'https://registry.npm.taobao.org'\n```\n\n#### 更简洁的输出\nyarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。\n\n更多信息：[migrating-from-npm](https://yarnpkg.com/en/docs/migrating-from-npm)\n\n\n### 使用\n#### 安装\n```code\n// 用Homebrew安装\n$ brew update\n$ brew install yarn\n\n// 用NPM安装\n$ npm install yarn -g\n```\n\n#### CLI\n##### 安装依赖\n安装package.json的依赖\n```code\n$ yarn\nor\n$ yarn install\n```\n\n本地安装某个模块依赖\n```code\n$ yarn add [package] \n->$ npm install [package] --save\n\n$ yarn add [package] [--dev/-D]\n->$ npm install --save-dev [package]\n```\n\n全局安装\n```code\n$ yarn global add [package]\n->$ npm install [--global/-g] [package]\n```\n\n##### 删除依赖\n```code\n$ yarn remove [package]\n->$ npm uninstall --save [package]\n```\n\n##### 升级依赖\n根据package.json文件重新安装到当前配置的最新版本\n```code\n$ yarn upgrade\n->$ rm -rf node_modules && npm install\n```\n\n更多与NPM的CLI对比：[cli-commands-comparison](https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison)\n更多CLI介绍：[cli-introduction](https://yarnpkg.com/en/docs/cli/)\n\n### 其他\n提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。\n\n### 总结\n好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。\n\n","slug":"Yarn-模块管理工具","published":1,"updated":"2017-01-24T07:41:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gwzzzv00070o858icokk9b","content":"<h3 id=\"u7B80_u4ECB\"><a href=\"#u7B80_u4ECB\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>2016年10月11日，facebook发布新的模块管理工具Yarn。<br>随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：</p>\n<ul>\n<li>安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。</li>\n<li>允许安装packages时执行代码，埋下安全隐患。</li>\n<li>安装packages的版本不够稳定等。</li>\n</ul>\n<p>为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。<br><a id=\"more\"></a></p>\n<h3 id=\"Yarn_vs_NPM\"><a href=\"#Yarn_vs_NPM\" class=\"headerlink\" title=\"Yarn vs NPM\"></a>Yarn vs NPM</h3><h4 id=\"yarn-lock\"><a href=\"#yarn-lock\" class=\"headerlink\" title=\"yarn.lock\"></a>yarn.lock</h4><p>NPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：</p>\n<ul>\n<li>指定版本号（1.2.2）：只安装指定版本</li>\n<li>波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）</li>\n<li>插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）</li>\n</ul>\n<p>当执行<code>npm install [package] --save</code>时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。</p>\n<p>yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的<code>npm-shrinkwrap.json</code>，需要通过执行 <code>npm shrinkwrap</code> 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。</p>\n<h4 id=\"u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\"><a href=\"#u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\" class=\"headerlink\" title=\"更快的模块下载\"></a>更快的模块下载</h4><p>yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。</p>\n<p>以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）</p>\n<p>除此，yarn还支持离线下载，前提是之前下过这个包。</p>\n<p>对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn config set registry &apos;https://registry.npm.taobao.org&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"u66F4_u7B80_u6D01_u7684_u8F93_u51FA\"><a href=\"#u66F4_u7B80_u6D01_u7684_u8F93_u51FA\" class=\"headerlink\" title=\"更简洁的输出\"></a>更简洁的输出</h4><p>yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。</p>\n<p>更多信息：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm\" target=\"_blank\" rel=\"external\">migrating-from-npm</a></p>\n<h3 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"u5B89_u88C5\"><a href=\"#u5B89_u88C5\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 用Homebrew安装</div><div class=\"line\">$ brew update</div><div class=\"line\">$ brew install yarn</div><div class=\"line\"></div><div class=\"line\">// 用NPM安装</div><div class=\"line\">$ npm install yarn -g</div></pre></td></tr></table></figure>\n<h4 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h4><h5 id=\"u5B89_u88C5_u4F9D_u8D56\"><a href=\"#u5B89_u88C5_u4F9D_u8D56\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><p>安装package.json的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn</div><div class=\"line\">or</div><div class=\"line\">$ yarn install</div></pre></td></tr></table></figure></p>\n<p>本地安装某个模块依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn add [package] </div><div class=\"line\">-&gt;$ npm install [package] --save</div><div class=\"line\"></div><div class=\"line\">$ yarn add [package] [--dev/-D]</div><div class=\"line\">-&gt;$ npm install --save-dev [package]</div></pre></td></tr></table></figure></p>\n<p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn global add [package]</div><div class=\"line\">-&gt;$ npm install [--global/-g] [package]</div></pre></td></tr></table></figure></p>\n<h5 id=\"u5220_u9664_u4F9D_u8D56\"><a href=\"#u5220_u9664_u4F9D_u8D56\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn remove [package]</div><div class=\"line\">-&gt;$ npm uninstall --save [package]</div></pre></td></tr></table></figure>\n<h5 id=\"u5347_u7EA7_u4F9D_u8D56\"><a href=\"#u5347_u7EA7_u4F9D_u8D56\" class=\"headerlink\" title=\"升级依赖\"></a>升级依赖</h5><p>根据package.json文件重新安装到当前配置的最新版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn upgrade</div><div class=\"line\">-&gt;$ rm -rf node_modules &amp;&amp; npm install</div></pre></td></tr></table></figure></p>\n<p>更多与NPM的CLI对比：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison\" target=\"_blank\" rel=\"external\">cli-commands-comparison</a><br>更多CLI介绍：<a href=\"https://yarnpkg.com/en/docs/cli/\" target=\"_blank\" rel=\"external\">cli-introduction</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。</p>\n","excerpt":"<h3 id=\"u7B80_u4ECB\"><a href=\"#u7B80_u4ECB\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>2016年10月11日，facebook发布新的模块管理工具Yarn。<br>随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：</p>\n<ul>\n<li>安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。</li>\n<li>允许安装packages时执行代码，埋下安全隐患。</li>\n<li>安装packages的版本不够稳定等。</li>\n</ul>\n<p>为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。<br>","more":"</p>\n<h3 id=\"Yarn_vs_NPM\"><a href=\"#Yarn_vs_NPM\" class=\"headerlink\" title=\"Yarn vs NPM\"></a>Yarn vs NPM</h3><h4 id=\"yarn-lock\"><a href=\"#yarn-lock\" class=\"headerlink\" title=\"yarn.lock\"></a>yarn.lock</h4><p>NPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）：</p>\n<ul>\n<li>指定版本号（1.2.2）：只安装指定版本</li>\n<li>波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2）</li>\n<li>插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2）</li>\n</ul>\n<p>当执行<code>npm install [package] --save</code>时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。</p>\n<p>yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的<code>npm-shrinkwrap.json</code>，需要通过执行 <code>npm shrinkwrap</code> 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。</p>\n<h4 id=\"u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\"><a href=\"#u66F4_u5FEB_u7684_u6A21_u5757_u4E0B_u8F7D\" class=\"headerlink\" title=\"更快的模块下载\"></a>更快的模块下载</h4><p>yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。</p>\n<p>以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度）</p>\n<p>除此，yarn还支持离线下载，前提是之前下过这个包。</p>\n<p>对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn config set registry &apos;https://registry.npm.taobao.org&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"u66F4_u7B80_u6D01_u7684_u8F93_u51FA\"><a href=\"#u66F4_u7B80_u6D01_u7684_u8F93_u51FA\" class=\"headerlink\" title=\"更简洁的输出\"></a>更简洁的输出</h4><p>yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。</p>\n<p>更多信息：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm\">migrating-from-npm</a></p>\n<h3 id=\"u4F7F_u7528\"><a href=\"#u4F7F_u7528\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"u5B89_u88C5\"><a href=\"#u5B89_u88C5\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 用Homebrew安装</div><div class=\"line\">$ brew update</div><div class=\"line\">$ brew install yarn</div><div class=\"line\"></div><div class=\"line\">// 用NPM安装</div><div class=\"line\">$ npm install yarn -g</div></pre></td></tr></table></figure>\n<h4 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h4><h5 id=\"u5B89_u88C5_u4F9D_u8D56\"><a href=\"#u5B89_u88C5_u4F9D_u8D56\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><p>安装package.json的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn</div><div class=\"line\">or</div><div class=\"line\">$ yarn install</div></pre></td></tr></table></figure></p>\n<p>本地安装某个模块依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn add [package] </div><div class=\"line\">-&gt;$ npm install [package] --save</div><div class=\"line\"></div><div class=\"line\">$ yarn add [package] [--dev/-D]</div><div class=\"line\">-&gt;$ npm install --save-dev [package]</div></pre></td></tr></table></figure></p>\n<p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn global add [package]</div><div class=\"line\">-&gt;$ npm install [--global/-g] [package]</div></pre></td></tr></table></figure></p>\n<h5 id=\"u5220_u9664_u4F9D_u8D56\"><a href=\"#u5220_u9664_u4F9D_u8D56\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn remove [package]</div><div class=\"line\">-&gt;$ npm uninstall --save [package]</div></pre></td></tr></table></figure>\n<h5 id=\"u5347_u7EA7_u4F9D_u8D56\"><a href=\"#u5347_u7EA7_u4F9D_u8D56\" class=\"headerlink\" title=\"升级依赖\"></a>升级依赖</h5><p>根据package.json文件重新安装到当前配置的最新版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn upgrade</div><div class=\"line\">-&gt;$ rm -rf node_modules &amp;&amp; npm install</div></pre></td></tr></table></figure></p>\n<p>更多与NPM的CLI对比：<a href=\"https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison\">cli-commands-comparison</a><br>更多CLI介绍：<a href=\"https://yarnpkg.com/en/docs/cli/\">cli-introduction</a></p>\n<h3 id=\"u5176_u4ED6\"><a href=\"#u5176_u4ED6\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。</p>"},{"title":"React Lifecycle","date":"2016-12-29T07:25:08.000Z","_content":"## 生命周期\n\nMore Info: [Component Specs and Lifecycle](http://reactjs.cn/react/docs/component-specs.html)\n\n## 组件渲染经历的生命周期\n\n### 第一次渲染：\n- getDefaultProps\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### 第二次渲染：\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### Props改变时：\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### State改变时：\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### 组件卸载时：\n- componentWillUnmont","source":"_posts/react-lifecycle.md","raw":"---\ntitle: React Lifecycle\ndate: 2016-12-29 15:25:08\ntags:\n- react\ncategories:\n- react\n---\n## 生命周期\n\nMore Info: [Component Specs and Lifecycle](http://reactjs.cn/react/docs/component-specs.html)\n\n## 组件渲染经历的生命周期\n\n### 第一次渲染：\n- getDefaultProps\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### 第二次渲染：\n- getInitialState\n- componentWillMount\n- render\n- componentDidMount\n\n### Props改变时：\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### State改变时：\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n### 组件卸载时：\n- componentWillUnmont","slug":"react-lifecycle","published":1,"updated":"2017-01-24T07:41:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gx000d000a0o85lr36o2bv","content":"<h2 id=\"u751F_u547D_u5468_u671F\"><a href=\"#u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>More Info: <a href=\"http://reactjs.cn/react/docs/component-specs.html\" target=\"_blank\" rel=\"external\">Component Specs and Lifecycle</a></p>\n<h2 id=\"u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\"><a href=\"#u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"组件渲染经历的生命周期\"></a>组件渲染经历的生命周期</h2><h3 id=\"u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第一次渲染：\"></a>第一次渲染：</h3><ul>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第二次渲染：\"></a>第二次渲染：</h3><ul>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"Props_u6539_u53D8_u65F6_uFF1A\"><a href=\"#Props_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"Props改变时：\"></a>Props改变时：</h3><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"State_u6539_u53D8_u65F6_uFF1A\"><a href=\"#State_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"State改变时：\"></a>State改变时：</h3><ul>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\"><a href=\"#u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\" class=\"headerlink\" title=\"组件卸载时：\"></a>组件卸载时：</h3><ul>\n<li>componentWillUnmont</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"u751F_u547D_u5468_u671F\"><a href=\"#u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>More Info: <a href=\"http://reactjs.cn/react/docs/component-specs.html\">Component Specs and Lifecycle</a></p>\n<h2 id=\"u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\"><a href=\"#u7EC4_u4EF6_u6E32_u67D3_u7ECF_u5386_u7684_u751F_u547D_u5468_u671F\" class=\"headerlink\" title=\"组件渲染经历的生命周期\"></a>组件渲染经历的生命周期</h2><h3 id=\"u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E00_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第一次渲染：\"></a>第一次渲染：</h3><ul>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\"><a href=\"#u7B2C_u4E8C_u6B21_u6E32_u67D3_uFF1A\" class=\"headerlink\" title=\"第二次渲染：\"></a>第二次渲染：</h3><ul>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h3 id=\"Props_u6539_u53D8_u65F6_uFF1A\"><a href=\"#Props_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"Props改变时：\"></a>Props改变时：</h3><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"State_u6539_u53D8_u65F6_uFF1A\"><a href=\"#State_u6539_u53D8_u65F6_uFF1A\" class=\"headerlink\" title=\"State改变时：\"></a>State改变时：</h3><ul>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3 id=\"u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\"><a href=\"#u7EC4_u4EF6_u5378_u8F7D_u65F6_uFF1A\" class=\"headerlink\" title=\"组件卸载时：\"></a>组件卸载时：</h3><ul>\n<li>componentWillUnmont</li>\n</ul>\n"},{"title":"webpack性能优化","date":"2017-03-30T02:50:20.000Z","banner":"https://future-team.github.io/blog-resources/imgs/webpack_optimization/banner_webpack.jpg","thumbnail":"https://future-team.github.io/blog-resources/imgs/webpack_optimization/banner_webpack.jpg","_content":"\nWebpack是前端模块加载及资源打包工具。\n\n> webpack takes modules with dependencies and generates static assets representing those modules.\n\n### 为什么要优化?\n随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。\n\n举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。\n\n<!-- more -->\n\n### 如何优化?\n#### 减少安装时间\n这部分跟Webpack无关，跟开发者的包管理工具和依赖模块有关。\n##### 1. 包管理工具\nnpm火了一阵之后开始被各种诟病，npm容易导致在多依赖关系中某些依赖没有指定版本号，导致拉取到的版本不一致，16年10月出了另一个模块管理工具`Yarn`，yarn可以缓存装过的包实现离线安装，安装速度快，也解决了版本号不确定的问题。\n\n具体关于yarn：[Yarn-模块管理工具](http://uedfamily.com/2017/01/11/cab/Yarn-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/)\n\n##### 2. 依赖模块\n每次开发完成可以检查一下是不是所有save到package.json以及import/require到文件中的模块都用到了，尽量减少可避免的时间消耗和代码冗余。\n\n除此，确定放在`dependencies`的依赖是否可以转移到`devDependencies`中放置，避免增加下载包的大小。\n\n#### 减少build&rebuild时间\n开发中一般都会开启`watch`的模式，每一次改动可以即时反映到浏览器上，这部分时间的消耗是至关重要的。\n\n##### 1. babel-loader优化\n1. 用`exclude`或`include`限制babel编译的文件范围。\n2. babel-loader可以缓存处理过的模块，`cacheDirectory`对于没有修改过的文件不会再重新编译。\n\n```code\n{\n    test: /\\.jsx?$/,\n    loaders: ['react-hot', 'babel-loader?cacheDirectory'],\n    exclude: /node_modules/\n}\n```\n\n##### 2. resolve.root VS resolve.modulesDirectories\n`root`是包含你的模块的绝对路径，`modulesDirectories`是一个目录数组，将解析当前目录及祖先目录，因此，只有在如`node_modules`的复杂路径下考虑使用`modulesDirectories`，大部分情景下使用`root`就足够了。\n```code\nresolve:{\n    root: path.resolve(__dirname, './src'),\n    modulesDirectories: ['node_modules','bower_components'],\n    extensions: ['', '.js', '.jsx']\n}\n```\n\n##### 3. resolve.alias \n`alias`把用户的一个请求重定向到另一个路径，减少路径搜索的成本。\n```code\nresolve:{\n    alias: {\n    \txyz: \"/absolute/path/to/file.js\"\n\t}\n}\n```\n\n##### 4. module.noParse\n`noParse`忽略对已知文件的解析，确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。\n```code\nmodule:{\n    noParse:[/jquery/]\n}\n```\n\n##### 5. DLLPlugin & DllReferencePlugin\nDLLPlugin通过前置依赖包的构建，来提高构建效率。打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码在打包的时候，只需要读取这个manifest文件就可以了。\n\nDll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。\n\n首先新建一个dll的配置文件如`webpack.dll.config.js`，entry只包含第三方库：\n```code\nmodule.exports = {\n\tentry: { 　// 只包含需要单独打包的依赖包\n\t\tvendor: ['react', 'react-dom', 'classnames']\n\t},\n\toutput: {\n\t\tpath: path.join(process.cwd(),'dist'),\n\t\tfilename: '[name].[chunkhash].js',\n\t\tlibrary: '[name]_[chunkhash]',\n\t},\n\tplugins: [\n\t\tnew webpack.DllPlugin({\n\t\t\tpath: 'manifest.json',\n\t\t\tname: '[name]_[chunkhash]',\n\t\t\tcontext: __dirname,\n\t\t}),\n\t],\n};\n```\n\n```code\n// manifest.json \n{\n  \"name\": \"vendor_45a4e5523d37b29e930b\",\n  \"content\": {\n    \"../node_modules/.npminstall/react/0.14.8/react/react.js\": 1,\n    \"../node_modules/.npminstall/react/0.14.8/react/lib/React.js\": 2,\n    ...\n    \"../node_modules/.npminstall/react-dom/0.14.8/react-dom/index.js\": 158,\n    \"../node_modules/.npminstall/classnames/2.2.5/classnames/index.js\": 159\n  }\n}\n```\n\n在普通配置文件如`webpack.config.js`中plugin增加`DllReferencePlugin`，这里的manifest对应刚刚的`manifest.json`：\n\n```code\nplugins: [\n\t...\n    new webpack.DllReferencePlugin({\n      context: __dirname,\n      manifest: require('./manifest.json'),\n    }),\n  ]\n```\n\n##### 6. happypack\nhappyPack利用了loader多进程去处理文件，同时还利用缓存来使得重新构建更快。\n工作流大概如下图：\n![happypack_workflow](https://future-team.github.io/blog-resources/imgs/webpack_optimization/happypack_workflow.png)\n\n详细可以参考：[happypack](https://github.com/amireh/happypack)\n\n#### 减少bundle包体积\n\n##### 1. 提取公共代码块\nWebpack提供了`webpack.optimize.CommonsChunkPlugin`的方法，对于多个输出文件之间重复使用的代码，整体减少了bundle包的大小，同时缓存固定依赖。\n```code\nentry: {\n    ...\n    vendor: ['react', 'react-dom', ...]\n},\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n        names: ['vendor', 'manifest'],\n    }),\n]\n```\n\n##### 2. 文件压缩\nWebpack提供了UglifyJS来压缩js文件，一般会减少`60%左右`的体积，有人推荐使用`webpack-parallel-uglify-plugin`来压缩代码能够得到更快速的体验。\n\n##### 3. 灵活使用externals\n最近的工作是开发提供给业务的React UI库，之前没有去仔细研究过`externals`，打包之后发现不压缩的文件有1兆＋，对业务中的模块下载和打包肯定产生一定影响了。\n认真开始研究性能优化之后发现问题出在`react-addons-css-transition-group`上，源码只有简单的一句：\n\n```code\nmodule.exports = require('react/lib/ReactCSSTransitionGroup');\n```\n\n把整个react模块又打包进来了，在`externals`中加入`react-addons-css-transition-group`之后打包体积剩下300+，非常显著。`externals`并没有那么智能去判断这个主模块是否已经放在不打包的行列里了，因此如使用到`react/lib/ReactDOM`也是需要单独列出来。\n\n```code\nexternals:[{\n    'react': 'React',\n    'react/lib/ReactDOM': 'ReactDOM',\n    'react-addons-css-transition-group': 'ReactCSSTransitionGroup'\n}]\n```\n\n另外，`externals`对应的值需要正确对应当前模块暴露的模块名，否则在通过script引入的情况下无法正常使用：\n```code\n<script src=\"https://npmcdn.com/react@0.14.2/dist/react.js\"></script>\n<script src=\"https://npmcdn.com/react-dom@0.14.3/dist/react-dom.js\"></script>\n<script src=\"./../dist/bundle.js\"></script>\n```\n\n那么在业务项目中使用的时候，当前模块找不到react相关的依赖会向外在项目的`node_modules`里面寻找依赖模块。\n\n### 总结\n林林总总提了一些优化点，部分是前人总结的优化点。最终还是要针对项目的需求来做优化。\n\n参考：[如何 10 倍提高你的 Webpack 构建效率](http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/)\n\n","source":"_posts/webpack性能优化.md","raw":"title: webpack性能优化\ndate: 2017-03-30 10:50:20\nbanner: https://future-team.github.io/blog-resources/imgs/webpack_optimization/banner_webpack.jpg\nthumbnail: https://future-team.github.io/blog-resources/imgs/webpack_optimization/banner_webpack.jpg\ntags:\n- webpack\n- 性能优化\n- 陈小饼\n---\n\nWebpack是前端模块加载及资源打包工具。\n\n> webpack takes modules with dependencies and generates static assets representing those modules.\n\n### 为什么要优化?\n随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。\n\n举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。\n\n<!-- more -->\n\n### 如何优化?\n#### 减少安装时间\n这部分跟Webpack无关，跟开发者的包管理工具和依赖模块有关。\n##### 1. 包管理工具\nnpm火了一阵之后开始被各种诟病，npm容易导致在多依赖关系中某些依赖没有指定版本号，导致拉取到的版本不一致，16年10月出了另一个模块管理工具`Yarn`，yarn可以缓存装过的包实现离线安装，安装速度快，也解决了版本号不确定的问题。\n\n具体关于yarn：[Yarn-模块管理工具](http://uedfamily.com/2017/01/11/cab/Yarn-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/)\n\n##### 2. 依赖模块\n每次开发完成可以检查一下是不是所有save到package.json以及import/require到文件中的模块都用到了，尽量减少可避免的时间消耗和代码冗余。\n\n除此，确定放在`dependencies`的依赖是否可以转移到`devDependencies`中放置，避免增加下载包的大小。\n\n#### 减少build&rebuild时间\n开发中一般都会开启`watch`的模式，每一次改动可以即时反映到浏览器上，这部分时间的消耗是至关重要的。\n\n##### 1. babel-loader优化\n1. 用`exclude`或`include`限制babel编译的文件范围。\n2. babel-loader可以缓存处理过的模块，`cacheDirectory`对于没有修改过的文件不会再重新编译。\n\n```code\n{\n    test: /\\.jsx?$/,\n    loaders: ['react-hot', 'babel-loader?cacheDirectory'],\n    exclude: /node_modules/\n}\n```\n\n##### 2. resolve.root VS resolve.modulesDirectories\n`root`是包含你的模块的绝对路径，`modulesDirectories`是一个目录数组，将解析当前目录及祖先目录，因此，只有在如`node_modules`的复杂路径下考虑使用`modulesDirectories`，大部分情景下使用`root`就足够了。\n```code\nresolve:{\n    root: path.resolve(__dirname, './src'),\n    modulesDirectories: ['node_modules','bower_components'],\n    extensions: ['', '.js', '.jsx']\n}\n```\n\n##### 3. resolve.alias \n`alias`把用户的一个请求重定向到另一个路径，减少路径搜索的成本。\n```code\nresolve:{\n    alias: {\n    \txyz: \"/absolute/path/to/file.js\"\n\t}\n}\n```\n\n##### 4. module.noParse\n`noParse`忽略对已知文件的解析，确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。\n```code\nmodule:{\n    noParse:[/jquery/]\n}\n```\n\n##### 5. DLLPlugin & DllReferencePlugin\nDLLPlugin通过前置依赖包的构建，来提高构建效率。打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码在打包的时候，只需要读取这个manifest文件就可以了。\n\nDll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。\n\n首先新建一个dll的配置文件如`webpack.dll.config.js`，entry只包含第三方库：\n```code\nmodule.exports = {\n\tentry: { 　// 只包含需要单独打包的依赖包\n\t\tvendor: ['react', 'react-dom', 'classnames']\n\t},\n\toutput: {\n\t\tpath: path.join(process.cwd(),'dist'),\n\t\tfilename: '[name].[chunkhash].js',\n\t\tlibrary: '[name]_[chunkhash]',\n\t},\n\tplugins: [\n\t\tnew webpack.DllPlugin({\n\t\t\tpath: 'manifest.json',\n\t\t\tname: '[name]_[chunkhash]',\n\t\t\tcontext: __dirname,\n\t\t}),\n\t],\n};\n```\n\n```code\n// manifest.json \n{\n  \"name\": \"vendor_45a4e5523d37b29e930b\",\n  \"content\": {\n    \"../node_modules/.npminstall/react/0.14.8/react/react.js\": 1,\n    \"../node_modules/.npminstall/react/0.14.8/react/lib/React.js\": 2,\n    ...\n    \"../node_modules/.npminstall/react-dom/0.14.8/react-dom/index.js\": 158,\n    \"../node_modules/.npminstall/classnames/2.2.5/classnames/index.js\": 159\n  }\n}\n```\n\n在普通配置文件如`webpack.config.js`中plugin增加`DllReferencePlugin`，这里的manifest对应刚刚的`manifest.json`：\n\n```code\nplugins: [\n\t...\n    new webpack.DllReferencePlugin({\n      context: __dirname,\n      manifest: require('./manifest.json'),\n    }),\n  ]\n```\n\n##### 6. happypack\nhappyPack利用了loader多进程去处理文件，同时还利用缓存来使得重新构建更快。\n工作流大概如下图：\n![happypack_workflow](https://future-team.github.io/blog-resources/imgs/webpack_optimization/happypack_workflow.png)\n\n详细可以参考：[happypack](https://github.com/amireh/happypack)\n\n#### 减少bundle包体积\n\n##### 1. 提取公共代码块\nWebpack提供了`webpack.optimize.CommonsChunkPlugin`的方法，对于多个输出文件之间重复使用的代码，整体减少了bundle包的大小，同时缓存固定依赖。\n```code\nentry: {\n    ...\n    vendor: ['react', 'react-dom', ...]\n},\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n        names: ['vendor', 'manifest'],\n    }),\n]\n```\n\n##### 2. 文件压缩\nWebpack提供了UglifyJS来压缩js文件，一般会减少`60%左右`的体积，有人推荐使用`webpack-parallel-uglify-plugin`来压缩代码能够得到更快速的体验。\n\n##### 3. 灵活使用externals\n最近的工作是开发提供给业务的React UI库，之前没有去仔细研究过`externals`，打包之后发现不压缩的文件有1兆＋，对业务中的模块下载和打包肯定产生一定影响了。\n认真开始研究性能优化之后发现问题出在`react-addons-css-transition-group`上，源码只有简单的一句：\n\n```code\nmodule.exports = require('react/lib/ReactCSSTransitionGroup');\n```\n\n把整个react模块又打包进来了，在`externals`中加入`react-addons-css-transition-group`之后打包体积剩下300+，非常显著。`externals`并没有那么智能去判断这个主模块是否已经放在不打包的行列里了，因此如使用到`react/lib/ReactDOM`也是需要单独列出来。\n\n```code\nexternals:[{\n    'react': 'React',\n    'react/lib/ReactDOM': 'ReactDOM',\n    'react-addons-css-transition-group': 'ReactCSSTransitionGroup'\n}]\n```\n\n另外，`externals`对应的值需要正确对应当前模块暴露的模块名，否则在通过script引入的情况下无法正常使用：\n```code\n<script src=\"https://npmcdn.com/react@0.14.2/dist/react.js\"></script>\n<script src=\"https://npmcdn.com/react-dom@0.14.3/dist/react-dom.js\"></script>\n<script src=\"./../dist/bundle.js\"></script>\n```\n\n那么在业务项目中使用的时候，当前模块找不到react相关的依赖会向外在项目的`node_modules`里面寻找依赖模块。\n\n### 总结\n林林总总提了一些优化点，部分是前人总结的优化点。最终还是要针对项目的需求来做优化。\n\n参考：[如何 10 倍提高你的 Webpack 构建效率](http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/)\n\n","slug":"webpack性能优化","published":1,"updated":"2017-04-04T13:11:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gx000h000b0o85ctr95nx4","content":"<p>Webpack是前端模块加载及资源打包工具。</p>\n<blockquote>\n<p>webpack takes modules with dependencies and generates static assets representing those modules.</p>\n</blockquote>\n<h3 id=\"u4E3A_u4EC0_u4E48_u8981_u4F18_u5316_3F\"><a href=\"#u4E3A_u4EC0_u4E48_u8981_u4F18_u5316_3F\" class=\"headerlink\" title=\"为什么要优化?\"></a>为什么要优化?</h3><p>随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。</p>\n<p>举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。</p>\n<a id=\"more\"></a>\n<h3 id=\"u5982_u4F55_u4F18_u5316_3F\"><a href=\"#u5982_u4F55_u4F18_u5316_3F\" class=\"headerlink\" title=\"如何优化?\"></a>如何优化?</h3><h4 id=\"u51CF_u5C11_u5B89_u88C5_u65F6_u95F4\"><a href=\"#u51CF_u5C11_u5B89_u88C5_u65F6_u95F4\" class=\"headerlink\" title=\"减少安装时间\"></a>减少安装时间</h4><p>这部分跟Webpack无关，跟开发者的包管理工具和依赖模块有关。</p>\n<h5 id=\"1-__u5305_u7BA1_u7406_u5DE5_u5177\"><a href=\"#1-__u5305_u7BA1_u7406_u5DE5_u5177\" class=\"headerlink\" title=\"1. 包管理工具\"></a>1. 包管理工具</h5><p>npm火了一阵之后开始被各种诟病，npm容易导致在多依赖关系中某些依赖没有指定版本号，导致拉取到的版本不一致，16年10月出了另一个模块管理工具<code>Yarn</code>，yarn可以缓存装过的包实现离线安装，安装速度快，也解决了版本号不确定的问题。</p>\n<p>具体关于yarn：<a href=\"http://uedfamily.com/2017/01/11/cab/Yarn-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/\" target=\"_blank\" rel=\"external\">Yarn-模块管理工具</a></p>\n<h5 id=\"2-__u4F9D_u8D56_u6A21_u5757\"><a href=\"#2-__u4F9D_u8D56_u6A21_u5757\" class=\"headerlink\" title=\"2. 依赖模块\"></a>2. 依赖模块</h5><p>每次开发完成可以检查一下是不是所有save到package.json以及import/require到文件中的模块都用到了，尽量减少可避免的时间消耗和代码冗余。</p>\n<p>除此，确定放在<code>dependencies</code>的依赖是否可以转移到<code>devDependencies</code>中放置，避免增加下载包的大小。</p>\n<h4 id=\"u51CF_u5C11build_26amp_3Brebuild_u65F6_u95F4\"><a href=\"#u51CF_u5C11build_26amp_3Brebuild_u65F6_u95F4\" class=\"headerlink\" title=\"减少build&amp;rebuild时间\"></a>减少build&amp;rebuild时间</h4><p>开发中一般都会开启<code>watch</code>的模式，每一次改动可以即时反映到浏览器上，这部分时间的消耗是至关重要的。</p>\n<h5 id=\"1-_babel-loader_u4F18_u5316\"><a href=\"#1-_babel-loader_u4F18_u5316\" class=\"headerlink\" title=\"1. babel-loader优化\"></a>1. babel-loader优化</h5><ol>\n<li>用<code>exclude</code>或<code>include</code>限制babel编译的文件范围。</li>\n<li>babel-loader可以缓存处理过的模块，<code>cacheDirectory</code>对于没有修改过的文件不会再重新编译。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    test: /\\.jsx?$/,</div><div class=\"line\">    loaders: [&apos;react-hot&apos;, &apos;babel-loader?cacheDirectory&apos;],</div><div class=\"line\">    exclude: /node_modules/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-_resolve-root_VS_resolve-modulesDirectories\"><a href=\"#2-_resolve-root_VS_resolve-modulesDirectories\" class=\"headerlink\" title=\"2. resolve.root VS resolve.modulesDirectories\"></a>2. resolve.root VS resolve.modulesDirectories</h5><p><code>root</code>是包含你的模块的绝对路径，<code>modulesDirectories</code>是一个目录数组，将解析当前目录及祖先目录，因此，只有在如<code>node_modules</code>的复杂路径下考虑使用<code>modulesDirectories</code>，大部分情景下使用<code>root</code>就足够了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve:&#123;</div><div class=\"line\">    root: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">    modulesDirectories: [&apos;node_modules&apos;,&apos;bower_components&apos;],</div><div class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"3-_resolve-alias\"><a href=\"#3-_resolve-alias\" class=\"headerlink\" title=\"3. resolve.alias\"></a>3. resolve.alias</h5><p><code>alias</code>把用户的一个请求重定向到另一个路径，减少路径搜索的成本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve:&#123;</div><div class=\"line\">    alias: &#123;</div><div class=\"line\">    \txyz: &quot;/absolute/path/to/file.js&quot;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"4-_module-noParse\"><a href=\"#4-_module-noParse\" class=\"headerlink\" title=\"4. module.noParse\"></a>4. module.noParse</h5><p><code>noParse</code>忽略对已知文件的解析，确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">module:&#123;</div><div class=\"line\">    noParse:[/jquery/]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"5-_DLLPlugin__26amp_3B_DllReferencePlugin\"><a href=\"#5-_DLLPlugin__26amp_3B_DllReferencePlugin\" class=\"headerlink\" title=\"5. DLLPlugin &amp; DllReferencePlugin\"></a>5. DLLPlugin &amp; DllReferencePlugin</h5><p>DLLPlugin通过前置依赖包的构建，来提高构建效率。打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码在打包的时候，只需要读取这个manifest文件就可以了。</p>\n<p>Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。</p>\n<p>首先新建一个dll的配置文件如<code>webpack.dll.config.js</code>，entry只包含第三方库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">\tentry: &#123; 　// 只包含需要单独打包的依赖包</div><div class=\"line\">\t\tvendor: [&apos;react&apos;, &apos;react-dom&apos;, &apos;classnames&apos;]</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\toutput: &#123;</div><div class=\"line\">\t\tpath: path.join(process.cwd(),&apos;dist&apos;),</div><div class=\"line\">\t\tfilename: &apos;[name].[chunkhash].js&apos;,</div><div class=\"line\">\t\tlibrary: &apos;[name]_[chunkhash]&apos;,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tplugins: [</div><div class=\"line\">\t\tnew webpack.DllPlugin(&#123;</div><div class=\"line\">\t\t\tpath: &apos;manifest.json&apos;,</div><div class=\"line\">\t\t\tname: &apos;[name]_[chunkhash]&apos;,</div><div class=\"line\">\t\t\tcontext: __dirname,</div><div class=\"line\">\t\t&#125;),</div><div class=\"line\">\t],</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// manifest.json </div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;vendor_45a4e5523d37b29e930b&quot;,</div><div class=\"line\">  &quot;content&quot;: &#123;</div><div class=\"line\">    &quot;../node_modules/.npminstall/react/0.14.8/react/react.js&quot;: 1,</div><div class=\"line\">    &quot;../node_modules/.npminstall/react/0.14.8/react/lib/React.js&quot;: 2,</div><div class=\"line\">    ...</div><div class=\"line\">    &quot;../node_modules/.npminstall/react-dom/0.14.8/react-dom/index.js&quot;: 158,</div><div class=\"line\">    &quot;../node_modules/.npminstall/classnames/2.2.5/classnames/index.js&quot;: 159</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在普通配置文件如<code>webpack.config.js</code>中plugin增加<code>DllReferencePlugin</code>，这里的manifest对应刚刚的<code>manifest.json</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">\t...</div><div class=\"line\">    new webpack.DllReferencePlugin(&#123;</div><div class=\"line\">      context: __dirname,</div><div class=\"line\">      manifest: require(&apos;./manifest.json&apos;),</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ]</div></pre></td></tr></table></figure>\n<h5 id=\"6-_happypack\"><a href=\"#6-_happypack\" class=\"headerlink\" title=\"6. happypack\"></a>6. happypack</h5><p>happyPack利用了loader多进程去处理文件，同时还利用缓存来使得重新构建更快。<br>工作流大概如下图：<br><img src=\"https://future-team.github.io/blog-resources/imgs/webpack_optimization/happypack_workflow.png\" alt=\"happypack_workflow\"></p>\n<p>详细可以参考：<a href=\"https://github.com/amireh/happypack\" target=\"_blank\" rel=\"external\">happypack</a></p>\n<h4 id=\"u51CF_u5C11bundle_u5305_u4F53_u79EF\"><a href=\"#u51CF_u5C11bundle_u5305_u4F53_u79EF\" class=\"headerlink\" title=\"减少bundle包体积\"></a>减少bundle包体积</h4><h5 id=\"1-__u63D0_u53D6_u516C_u5171_u4EE3_u7801_u5757\"><a href=\"#1-__u63D0_u53D6_u516C_u5171_u4EE3_u7801_u5757\" class=\"headerlink\" title=\"1. 提取公共代码块\"></a>1. 提取公共代码块</h5><p>Webpack提供了<code>webpack.optimize.CommonsChunkPlugin</code>的方法，对于多个输出文件之间重复使用的代码，整体减少了bundle包的大小，同时缓存固定依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    vendor: [&apos;react&apos;, &apos;react-dom&apos;, ...]</div><div class=\"line\">&#125;,</div><div class=\"line\">plugins: [</div><div class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        names: [&apos;vendor&apos;, &apos;manifest&apos;],</div><div class=\"line\">    &#125;),</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-__u6587_u4EF6_u538B_u7F29\"><a href=\"#2-__u6587_u4EF6_u538B_u7F29\" class=\"headerlink\" title=\"2. 文件压缩\"></a>2. 文件压缩</h5><p>Webpack提供了UglifyJS来压缩js文件，一般会减少<code>60%左右</code>的体积，有人推荐使用<code>webpack-parallel-uglify-plugin</code>来压缩代码能够得到更快速的体验。</p>\n<h5 id=\"3-__u7075_u6D3B_u4F7F_u7528externals\"><a href=\"#3-__u7075_u6D3B_u4F7F_u7528externals\" class=\"headerlink\" title=\"3. 灵活使用externals\"></a>3. 灵活使用externals</h5><p>最近的工作是开发提供给业务的React UI库，之前没有去仔细研究过<code>externals</code>，打包之后发现不压缩的文件有1兆＋，对业务中的模块下载和打包肯定产生一定影响了。<br>认真开始研究性能优化之后发现问题出在<code>react-addons-css-transition-group</code>上，源码只有简单的一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = require(&apos;react/lib/ReactCSSTransitionGroup&apos;);</div></pre></td></tr></table></figure>\n<p>把整个react模块又打包进来了，在<code>externals</code>中加入<code>react-addons-css-transition-group</code>之后打包体积剩下300+，非常显著。<code>externals</code>并没有那么智能去判断这个主模块是否已经放在不打包的行列里了，因此如使用到<code>react/lib/ReactDOM</code>也是需要单独列出来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals:[&#123;</div><div class=\"line\">    &apos;react&apos;: &apos;React&apos;,</div><div class=\"line\">    &apos;react/lib/ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">    &apos;react-addons-css-transition-group&apos;: &apos;ReactCSSTransitionGroup&apos;</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure>\n<p>另外，<code>externals</code>对应的值需要正确对应当前模块暴露的模块名，否则在通过script引入的情况下无法正常使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://npmcdn.com/react@0.14.2/dist/react.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://npmcdn.com/react-dom@0.14.3/dist/react-dom.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;./../dist/bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>那么在业务项目中使用的时候，当前模块找不到react相关的依赖会向外在项目的<code>node_modules</code>里面寻找依赖模块。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>林林总总提了一些优化点，部分是前人总结的优化点。最终还是要针对项目的需求来做优化。</p>\n<p>参考：<a href=\"http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/\" target=\"_blank\" rel=\"external\">如何 10 倍提高你的 Webpack 构建效率</a></p>\n","excerpt":"<p>Webpack是前端模块加载及资源打包工具。</p>\n<blockquote>\n<p>webpack takes modules with dependencies and generates static assets representing those modules.</p>\n</blockquote>\n<h3 id=\"u4E3A_u4EC0_u4E48_u8981_u4F18_u5316_3F\"><a href=\"#u4E3A_u4EC0_u4E48_u8981_u4F18_u5316_3F\" class=\"headerlink\" title=\"为什么要优化?\"></a>为什么要优化?</h3><p>随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。</p>\n<p>举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。</p>","more":"<h3 id=\"u5982_u4F55_u4F18_u5316_3F\"><a href=\"#u5982_u4F55_u4F18_u5316_3F\" class=\"headerlink\" title=\"如何优化?\"></a>如何优化?</h3><h4 id=\"u51CF_u5C11_u5B89_u88C5_u65F6_u95F4\"><a href=\"#u51CF_u5C11_u5B89_u88C5_u65F6_u95F4\" class=\"headerlink\" title=\"减少安装时间\"></a>减少安装时间</h4><p>这部分跟Webpack无关，跟开发者的包管理工具和依赖模块有关。</p>\n<h5 id=\"1-__u5305_u7BA1_u7406_u5DE5_u5177\"><a href=\"#1-__u5305_u7BA1_u7406_u5DE5_u5177\" class=\"headerlink\" title=\"1. 包管理工具\"></a>1. 包管理工具</h5><p>npm火了一阵之后开始被各种诟病，npm容易导致在多依赖关系中某些依赖没有指定版本号，导致拉取到的版本不一致，16年10月出了另一个模块管理工具<code>Yarn</code>，yarn可以缓存装过的包实现离线安装，安装速度快，也解决了版本号不确定的问题。</p>\n<p>具体关于yarn：<a href=\"http://uedfamily.com/2017/01/11/cab/Yarn-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/\">Yarn-模块管理工具</a></p>\n<h5 id=\"2-__u4F9D_u8D56_u6A21_u5757\"><a href=\"#2-__u4F9D_u8D56_u6A21_u5757\" class=\"headerlink\" title=\"2. 依赖模块\"></a>2. 依赖模块</h5><p>每次开发完成可以检查一下是不是所有save到package.json以及import/require到文件中的模块都用到了，尽量减少可避免的时间消耗和代码冗余。</p>\n<p>除此，确定放在<code>dependencies</code>的依赖是否可以转移到<code>devDependencies</code>中放置，避免增加下载包的大小。</p>\n<h4 id=\"u51CF_u5C11build_26amp_3Brebuild_u65F6_u95F4\"><a href=\"#u51CF_u5C11build_26amp_3Brebuild_u65F6_u95F4\" class=\"headerlink\" title=\"减少build&amp;rebuild时间\"></a>减少build&amp;rebuild时间</h4><p>开发中一般都会开启<code>watch</code>的模式，每一次改动可以即时反映到浏览器上，这部分时间的消耗是至关重要的。</p>\n<h5 id=\"1-_babel-loader_u4F18_u5316\"><a href=\"#1-_babel-loader_u4F18_u5316\" class=\"headerlink\" title=\"1. babel-loader优化\"></a>1. babel-loader优化</h5><ol>\n<li>用<code>exclude</code>或<code>include</code>限制babel编译的文件范围。</li>\n<li>babel-loader可以缓存处理过的模块，<code>cacheDirectory</code>对于没有修改过的文件不会再重新编译。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    test: /\\.jsx?$/,</div><div class=\"line\">    loaders: [&apos;react-hot&apos;, &apos;babel-loader?cacheDirectory&apos;],</div><div class=\"line\">    exclude: /node_modules/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-_resolve-root_VS_resolve-modulesDirectories\"><a href=\"#2-_resolve-root_VS_resolve-modulesDirectories\" class=\"headerlink\" title=\"2. resolve.root VS resolve.modulesDirectories\"></a>2. resolve.root VS resolve.modulesDirectories</h5><p><code>root</code>是包含你的模块的绝对路径，<code>modulesDirectories</code>是一个目录数组，将解析当前目录及祖先目录，因此，只有在如<code>node_modules</code>的复杂路径下考虑使用<code>modulesDirectories</code>，大部分情景下使用<code>root</code>就足够了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve:&#123;</div><div class=\"line\">    root: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">    modulesDirectories: [&apos;node_modules&apos;,&apos;bower_components&apos;],</div><div class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"3-_resolve-alias\"><a href=\"#3-_resolve-alias\" class=\"headerlink\" title=\"3. resolve.alias\"></a>3. resolve.alias</h5><p><code>alias</code>把用户的一个请求重定向到另一个路径，减少路径搜索的成本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve:&#123;</div><div class=\"line\">    alias: &#123;</div><div class=\"line\">    \txyz: &quot;/absolute/path/to/file.js&quot;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"4-_module-noParse\"><a href=\"#4-_module-noParse\" class=\"headerlink\" title=\"4. module.noParse\"></a>4. module.noParse</h5><p><code>noParse</code>忽略对已知文件的解析，确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">module:&#123;</div><div class=\"line\">    noParse:[/jquery/]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"5-_DLLPlugin__26amp_3B_DllReferencePlugin\"><a href=\"#5-_DLLPlugin__26amp_3B_DllReferencePlugin\" class=\"headerlink\" title=\"5. DLLPlugin &amp; DllReferencePlugin\"></a>5. DLLPlugin &amp; DllReferencePlugin</h5><p>DLLPlugin通过前置依赖包的构建，来提高构建效率。打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码在打包的时候，只需要读取这个manifest文件就可以了。</p>\n<p>Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。</p>\n<p>首先新建一个dll的配置文件如<code>webpack.dll.config.js</code>，entry只包含第三方库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">\tentry: &#123; 　// 只包含需要单独打包的依赖包</div><div class=\"line\">\t\tvendor: [&apos;react&apos;, &apos;react-dom&apos;, &apos;classnames&apos;]</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\toutput: &#123;</div><div class=\"line\">\t\tpath: path.join(process.cwd(),&apos;dist&apos;),</div><div class=\"line\">\t\tfilename: &apos;[name].[chunkhash].js&apos;,</div><div class=\"line\">\t\tlibrary: &apos;[name]_[chunkhash]&apos;,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tplugins: [</div><div class=\"line\">\t\tnew webpack.DllPlugin(&#123;</div><div class=\"line\">\t\t\tpath: &apos;manifest.json&apos;,</div><div class=\"line\">\t\t\tname: &apos;[name]_[chunkhash]&apos;,</div><div class=\"line\">\t\t\tcontext: __dirname,</div><div class=\"line\">\t\t&#125;),</div><div class=\"line\">\t],</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// manifest.json </div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;vendor_45a4e5523d37b29e930b&quot;,</div><div class=\"line\">  &quot;content&quot;: &#123;</div><div class=\"line\">    &quot;../node_modules/.npminstall/react/0.14.8/react/react.js&quot;: 1,</div><div class=\"line\">    &quot;../node_modules/.npminstall/react/0.14.8/react/lib/React.js&quot;: 2,</div><div class=\"line\">    ...</div><div class=\"line\">    &quot;../node_modules/.npminstall/react-dom/0.14.8/react-dom/index.js&quot;: 158,</div><div class=\"line\">    &quot;../node_modules/.npminstall/classnames/2.2.5/classnames/index.js&quot;: 159</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在普通配置文件如<code>webpack.config.js</code>中plugin增加<code>DllReferencePlugin</code>，这里的manifest对应刚刚的<code>manifest.json</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">\t...</div><div class=\"line\">    new webpack.DllReferencePlugin(&#123;</div><div class=\"line\">      context: __dirname,</div><div class=\"line\">      manifest: require(&apos;./manifest.json&apos;),</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ]</div></pre></td></tr></table></figure>\n<h5 id=\"6-_happypack\"><a href=\"#6-_happypack\" class=\"headerlink\" title=\"6. happypack\"></a>6. happypack</h5><p>happyPack利用了loader多进程去处理文件，同时还利用缓存来使得重新构建更快。<br>工作流大概如下图：<br><img src=\"https://future-team.github.io/blog-resources/imgs/webpack_optimization/happypack_workflow.png\" alt=\"happypack_workflow\"></p>\n<p>详细可以参考：<a href=\"https://github.com/amireh/happypack\">happypack</a></p>\n<h4 id=\"u51CF_u5C11bundle_u5305_u4F53_u79EF\"><a href=\"#u51CF_u5C11bundle_u5305_u4F53_u79EF\" class=\"headerlink\" title=\"减少bundle包体积\"></a>减少bundle包体积</h4><h5 id=\"1-__u63D0_u53D6_u516C_u5171_u4EE3_u7801_u5757\"><a href=\"#1-__u63D0_u53D6_u516C_u5171_u4EE3_u7801_u5757\" class=\"headerlink\" title=\"1. 提取公共代码块\"></a>1. 提取公共代码块</h5><p>Webpack提供了<code>webpack.optimize.CommonsChunkPlugin</code>的方法，对于多个输出文件之间重复使用的代码，整体减少了bundle包的大小，同时缓存固定依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    vendor: [&apos;react&apos;, &apos;react-dom&apos;, ...]</div><div class=\"line\">&#125;,</div><div class=\"line\">plugins: [</div><div class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        names: [&apos;vendor&apos;, &apos;manifest&apos;],</div><div class=\"line\">    &#125;),</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-__u6587_u4EF6_u538B_u7F29\"><a href=\"#2-__u6587_u4EF6_u538B_u7F29\" class=\"headerlink\" title=\"2. 文件压缩\"></a>2. 文件压缩</h5><p>Webpack提供了UglifyJS来压缩js文件，一般会减少<code>60%左右</code>的体积，有人推荐使用<code>webpack-parallel-uglify-plugin</code>来压缩代码能够得到更快速的体验。</p>\n<h5 id=\"3-__u7075_u6D3B_u4F7F_u7528externals\"><a href=\"#3-__u7075_u6D3B_u4F7F_u7528externals\" class=\"headerlink\" title=\"3. 灵活使用externals\"></a>3. 灵活使用externals</h5><p>最近的工作是开发提供给业务的React UI库，之前没有去仔细研究过<code>externals</code>，打包之后发现不压缩的文件有1兆＋，对业务中的模块下载和打包肯定产生一定影响了。<br>认真开始研究性能优化之后发现问题出在<code>react-addons-css-transition-group</code>上，源码只有简单的一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = require(&apos;react/lib/ReactCSSTransitionGroup&apos;);</div></pre></td></tr></table></figure>\n<p>把整个react模块又打包进来了，在<code>externals</code>中加入<code>react-addons-css-transition-group</code>之后打包体积剩下300+，非常显著。<code>externals</code>并没有那么智能去判断这个主模块是否已经放在不打包的行列里了，因此如使用到<code>react/lib/ReactDOM</code>也是需要单独列出来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals:[&#123;</div><div class=\"line\">    &apos;react&apos;: &apos;React&apos;,</div><div class=\"line\">    &apos;react/lib/ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">    &apos;react-addons-css-transition-group&apos;: &apos;ReactCSSTransitionGroup&apos;</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure>\n<p>另外，<code>externals</code>对应的值需要正确对应当前模块暴露的模块名，否则在通过script引入的情况下无法正常使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://npmcdn.com/react@0.14.2/dist/react.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://npmcdn.com/react-dom@0.14.3/dist/react-dom.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;./../dist/bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>那么在业务项目中使用的时候，当前模块找不到react相关的依赖会向外在项目的<code>node_modules</code>里面寻找依赖模块。</p>\n<h3 id=\"u603B_u7ED3\"><a href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>林林总总提了一些优化点，部分是前人总结的优化点。最终还是要针对项目的需求来做优化。</p>\n<p>参考：<a href=\"http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/\">如何 10 倍提高你的 Webpack 构建效率</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj2gx000d000a0o85lr36o2bv","category_id":"cj2gx000600080o85r2t6i8cc","_id":"cj2gx000k000e0o854r8agx25"},{"post_id":"cj2gwzzzt00060o852mxth1tc","category_id":"cj2gx000j000c0o85bmex9n9l","_id":"cj2gx000l000i0o85aw4ydr4q"},{"post_id":"cj2gwzzz900000o85tawegq90","category_id":"cj2gwzzzl00030o85r9o3ys08","_id":"cj2gx000m000n0o85qn5vg83h"},{"post_id":"cj2gwzzz900000o85tawegq90","category_id":"cj2gx000k000f0o85eqrrrzi2","_id":"cj2gx000n000q0o85ylg5r21f"},{"post_id":"cj2gwzzzo00050o85co70f7vq","category_id":"cj2gx000600080o85r2t6i8cc","_id":"cj2gx000o000v0o85sz9ju4te"},{"post_id":"cj2gwzzzo00050o85co70f7vq","category_id":"cj2gx000n000p0o85pb4zcbll","_id":"cj2gx000p000x0o85umzuydwu"},{"post_id":"cj2gwzzzv00070o858icokk9b","category_id":"cj2gx000l000k0o852vy6sy42","_id":"cj2gx000r00140o85ln6iizr5"},{"post_id":"cj2gwzzzv00070o858icokk9b","category_id":"cj2gx000o000u0o851olhyki1","_id":"cj2gx000r00160o852xivoa4p"},{"post_id":"cj2gwzzzv00070o858icokk9b","category_id":"cj2gx000p000y0o85y3phm35y","_id":"cj2gx000r00180o85fhvejkj7"}],"PostTag":[{"post_id":"cj2gwzzz900000o85tawegq90","tag_id":"cj2gwzzzn00040o85eqhid1nf","_id":"cj2gx000l000h0o85yfe5jhil"},{"post_id":"cj2gwzzz900000o85tawegq90","tag_id":"cj2gx000700090o855lo93kc3","_id":"cj2gx000l000j0o85txoyii2e"},{"post_id":"cj2gwzzz900000o85tawegq90","tag_id":"cj2gx000j000d0o85oea25ero","_id":"cj2gx000m000m0o85oa40ip0p"},{"post_id":"cj2gwzzzi00020o85jxr8xv85","tag_id":"cj2gx000l000g0o856b973nc1","_id":"cj2gx000o000r0o85ilz6mg9k"},{"post_id":"cj2gwzzzi00020o85jxr8xv85","tag_id":"cj2gx000j000d0o85oea25ero","_id":"cj2gx000o000s0o857an32j75"},{"post_id":"cj2gwzzzo00050o85co70f7vq","tag_id":"cj2gx000m000o0o85cxglwq4e","_id":"cj2gx000q00100o85wt63w2ze"},{"post_id":"cj2gwzzzo00050o85co70f7vq","tag_id":"cj2gx000o000t0o856mfx3hmx","_id":"cj2gx000q00110o85hik8jase"},{"post_id":"cj2gwzzzo00050o85co70f7vq","tag_id":"cj2gx000j000d0o85oea25ero","_id":"cj2gx000r00130o85kpyhla0f"},{"post_id":"cj2gwzzzt00060o852mxth1tc","tag_id":"cj2gx000q000z0o853jh2yk82","_id":"cj2gx000r00150o851xo7hqhl"},{"post_id":"cj2gwzzzv00070o858icokk9b","tag_id":"cj2gx000q00120o85yjsukh6z","_id":"cj2gx000s001c0o8581ms4qm5"},{"post_id":"cj2gwzzzv00070o858icokk9b","tag_id":"cj2gx000r00170o85nnfsvxq7","_id":"cj2gx000s001d0o85xpuqztuz"},{"post_id":"cj2gwzzzv00070o858icokk9b","tag_id":"cj2gx000r00190o85kyxibhd2","_id":"cj2gx000s001f0o8573ornmlk"},{"post_id":"cj2gwzzzv00070o858icokk9b","tag_id":"cj2gx000j000d0o85oea25ero","_id":"cj2gx000t001g0o8518i1vcgr"},{"post_id":"cj2gx000d000a0o85lr36o2bv","tag_id":"cj2gx000m000o0o85cxglwq4e","_id":"cj2gx000t001i0o85fgzjsur5"},{"post_id":"cj2gx000h000b0o85ctr95nx4","tag_id":"cj2gx000s001e0o85ri0qtl1l","_id":"cj2gx000t001k0o85wso5k0fu"},{"post_id":"cj2gx000h000b0o85ctr95nx4","tag_id":"cj2gx000t001h0o85x2ylcmw4","_id":"cj2gx000t001l0o85bxhe6q3n"},{"post_id":"cj2gx000h000b0o85ctr95nx4","tag_id":"cj2gx000j000d0o85oea25ero","_id":"cj2gx000u001m0o85opnm3uod"}],"Tag":[{"name":"promise","_id":"cj2gwzzzn00040o85eqhid1nf"},{"name":"异步编程","_id":"cj2gx000700090o855lo93kc3"},{"name":"陈小饼","_id":"cj2gx000j000d0o85oea25ero"},{"name":"hybrid","_id":"cj2gx000l000g0o856b973nc1"},{"name":"react","_id":"cj2gx000m000o0o85cxglwq4e"},{"name":"test","_id":"cj2gx000o000t0o856mfx3hmx"},{"name":"http","_id":"cj2gx000q000z0o853jh2yk82"},{"name":"Yarn","_id":"cj2gx000q00120o85yjsukh6z"},{"name":"NPM","_id":"cj2gx000r00170o85nnfsvxq7"},{"name":"工具","_id":"cj2gx000r00190o85kyxibhd2"},{"name":"webpack","_id":"cj2gx000s001e0o85ri0qtl1l"},{"name":"性能优化","_id":"cj2gx000t001h0o85x2ylcmw4"}]}}